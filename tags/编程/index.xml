<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>编程 on Juiceright</title>
    <link>https://cywd123.github.io/tags/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on Juiceright</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 Dec 2025 15:10:48 +0000</lastBuildDate>
    <atom:link href="https://cywd123.github.io/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ppt word快速转换PDF小脚本</title>
      <link>https://cywd123.github.io/old/posts/vhulvqwmjm/</link>
      <pubDate>Mon, 01 Sep 2025 00:11:31 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/vhulvqwmjm/</guid>
      <description>&lt;h2 id=&#34;ppt-word快速转换pdf小脚本&#34;&gt;ppt word快速转换PDF小脚本&lt;/h2&gt;
&lt;p&gt;这个vbs小脚本可以快速将同一目录下的ppt、pptx、doc、docx文件转换成PDF，即点即用，非常方便。&lt;/p&gt;
&lt;h3 id=&#34;office----ppt-word快速转换pdf-officevbs-&#34;&gt;Office   （ ppt word快速转换PDF-Office.vbs ）&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-vbscript&#34; data-lang=&#34;vbscript&#34;&gt;On Error Resume Next
MsgBox &amp;#34;Start converting PPT and Word files into PDF format. Please ensure Office or WPS is installed. Please wait...&amp;#34;, vbInformation, &amp;#34;Conversion Start&amp;#34;

Const wdExportFormatPDF = 17
Dim oWord, ppt, fso, isOffice, isWPS

&amp;#39; 初始化变量
Set fso = WScript.CreateObject(&amp;#34;Scripting.Filesystemobject&amp;#34;)
isOffice = False
isWPS = False

Set oWord = WScript.CreateObject(&amp;#34;KWPS.Application&amp;#34;)
Set ppt = CreateObject(&amp;#34;KWPP.application&amp;#34;)
If IsObject(oWord) And IsObject(ppt) Then
    isOffice = True
Else
    If IsObject(oWord) Then oWord.Quit
    If IsObject(ppt) Then ppt.Quit
    Set oWord = Nothing
    Set ppt = Nothing
    
    Set oWord = WScript.CreateObject(&amp;#34;Word.Application&amp;#34;)
    Set ppt = CreateObject(&amp;#34;PowerPoint.application&amp;#34;)
    If IsObject(oWord) And IsObject(ppt) Then
        isWPS = True
    Else
        &amp;#39; 两种办公软件都未安装
        If IsObject(oWord) Then oWord.Quit
        If IsObject(ppt) Then ppt.Quit
        Set oWord = Nothing
        Set ppt = Nothing
        Set fso = Nothing
        MsgBox &amp;#34;Failed to find Office or WPS. Please install one of them first.&amp;#34;, vbCritical, &amp;#34;Error&amp;#34;
        WScript.Quit
    End If
End If

&amp;#39; 开始处理文件夹
ProcessFolder fso.GetFolder(&amp;#34;.&amp;#34;)

&amp;#39; 清理对象
If IsObject(oWord) Then
    oWord.Quit
    Set oWord = Nothing
End If
If IsObject(ppt) Then
    ppt.Quit
    Set ppt = Nothing
End If
Set fso = Nothing

MsgBox &amp;#34;PPT and Word files have been successfully converted into PDF format!&amp;#34;, vbInformation, &amp;#34;Conversion Complete&amp;#34;

Sub ProcessFolder(folder)
    Dim ff, subFolder, pdfPath
    
    For Each ff In folder.Files
        &amp;#39; 处理Word文件 (.doc, .docx) 且不是临时文件
        If (LCase(Right(ff.Name, 4)) = &amp;#34;.doc&amp;#34; Or LCase(Right(ff.Name, 5)) = &amp;#34;.docx&amp;#34;) And Left(ff.Name, 1) &amp;lt;&amp;gt; &amp;#34;~&amp;#34; Then
            pdfPath = Left(ff.Path, InStrRev(ff.Path, &amp;#34;.&amp;#34;)) &amp;amp; &amp;#34;pdf&amp;#34;
            Set oDoc = oWord.Documents.Open(ff.Path)
            oDoc.ExportAsFixedFormat pdfPath, wdExportFormatPDF
            oDoc.Close
            Set oDoc = Nothing
        End If
        
        &amp;#39; 处理PowerPoint文件 (.ppt, .pptx) 且不是临时文件
        If (LCase(Right(ff.Name, 4)) = &amp;#34;.ppt&amp;#34; Or LCase(Right(ff.Name, 5)) = &amp;#34;.pptx&amp;#34;) And Left(ff.Name, 1) &amp;lt;&amp;gt; &amp;#34;~&amp;#34; Then
            pdfPath = Left(ff.Path, InStrRev(ff.Path, &amp;#34;.&amp;#34;)) &amp;amp; &amp;#34;pdf&amp;#34;
            Set pptfile = ppt.Presentations.Open(ff.Path, False, False, False)
            pptfile.SaveAs pdfPath, 32, False
            pptfile.Close
            Set pptfile = Nothing
        End If
    Next
    
    &amp;#39; 递归处理子文件夹
    For Each subFolder In folder.SubFolders
        ProcessFolder subFolder
    Next
End Sub
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;wps---ppt-word快速转换pdf-wpsvbs-&#34;&gt;WPS  ( ppt word快速转换PDF-WPS.vbs )&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-vbscript&#34; data-lang=&#34;vbscript&#34;&gt;On Error Resume Next
    MsgBox &amp;#34;开始转换PPT和Word文件为PDF格式，请稍候...&amp;#34;
    Const wdExportFormatPDF = 17
    Set oWord = WScript.CreateObject(&amp;#34;KWPS.Application&amp;#34;)
	Set ppt = CreateObject(&amp;#34;KWPP.application&amp;#34;)
    Set fso = WScript.CreateObject(&amp;#34;Scripting.Filesystemobject&amp;#34;)
    Set fds=fso.GetFolder(&amp;#34;.&amp;#34;)
    Set ffs=fds.Files
	
    For Each ff In ffs
    If (LCase(Right(ff.Name,4))=&amp;#34;.doc&amp;#34; Or LCase(Right(ff.Name,4))=&amp;#34;docx&amp;#34; ) And Left(ff.Name,1)&amp;lt;&amp;gt;&amp;#34;~&amp;#34; Then
        Set oDoc=oWord.Documents.Open(ff.Path)
        oDoc.ExportAsFixedFormat Left(ff.Path,InStrRev(ff.Path,&amp;#34;.&amp;#34;))&amp;amp;&amp;#34;pdf&amp;#34;,wdExportFormatPDF
        oDoc.Close

    End If
	If (LCase(Right(ff.Name,4))=&amp;#34;.ppt&amp;#34; Or LCase(Right(ff.Name,4))=&amp;#34;pptx&amp;#34; ) And Left(ff.Name,1)&amp;lt;&amp;gt;&amp;#34;~&amp;#34; Then
        Set pptfile = ppt.Presentations.Open(ff.Path,false,false,false)
        pptfile.Saveas Left(ff.Path,InStrRev(ff.Path,&amp;#34;.&amp;#34;))&amp;amp;&amp;#34;pdf&amp;#34;,32,false
		pptfile.Close
    End If
    Next
    odoc.Close
    oword.Quit
	pptfile.Close
	ppt.Quit
    Set oDoc=Nothing
    Set oWord =Nothing
	Set pptfile = Nothing
	Set ppt = Nothing
	MsgBox &amp;#34;PPT和Word文件已成功转换为PDF格式！&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;合并-ppt-word快速转换pdf-合并vbs&#34;&gt;合并 （ppt word快速转换PDF-合并.vbs）&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-vbscript&#34; data-lang=&#34;vbscript&#34;&gt;On Error Resume Next
MsgBox &amp;#34;开始转换PPT和Word文件为PDF格式，请稍候...&amp;#34;
Const wdExportFormatPDF = 17
Dim oWord, ppt, isWPS, isOffice

&amp;#39; 尝试创建WPS对象
Set oWord = WScript.CreateObject(&amp;#34;KWPS.Application&amp;#34;)
Set ppt = CreateObject(&amp;#34;KWPP.Application&amp;#34;)

&amp;#39; 检测是否是WPS环境
If Not oWord Is Nothing And Not ppt Is Nothing Then
    isWPS = True
Else
    &amp;#39; 尝试创建Office对象
    Set oWord = WScript.CreateObject(&amp;#34;Word.Application&amp;#34;)
    Set ppt = CreateObject(&amp;#34;PowerPoint.Application&amp;#34;)
    If Not oWord Is Nothing And Not ppt Is Nothing Then
        isOffice = True
    Else
        MsgBox &amp;#34;未检测到WPS或Office，请确保已安装其中一款办公软件！&amp;#34;
        WScript.Quit
    End If
End If

Set fso = WScript.CreateObject(&amp;#34;Scripting.FileSystemObject&amp;#34;)
Set fds = fso.GetFolder(&amp;#34;.&amp;#34;)
Set ffs = fds.Files

For Each ff In ffs
    &amp;#39; 处理Word文件
    If (LCase(Right(ff.Name, 4)) = &amp;#34;.doc&amp;#34; Or LCase(Right(ff.Name, 4)) = &amp;#34;docx&amp;#34;) And Left(ff.Name, 1) &amp;lt;&amp;gt; &amp;#34;~&amp;#34; Then
        Set oDoc = oWord.Documents.Open(ff.Path)
        oDoc.ExportAsFixedFormat Left(ff.Path, InStrRev(ff.Path, &amp;#34;.&amp;#34;)) &amp;amp; &amp;#34;pdf&amp;#34;, wdExportFormatPDF
        oDoc.Close
        Set oDoc = Nothing
    End If
    
    &amp;#39; 处理PPT文件
    If (LCase(Right(ff.Name, 4)) = &amp;#34;.ppt&amp;#34; Or LCase(Right(ff.Name, 4)) = &amp;#34;pptx&amp;#34;) And Left(ff.Name, 1) &amp;lt;&amp;gt; &amp;#34;~&amp;#34; Then
        Set pptfile = ppt.Presentations.Open(ff.Path, False, False, False)
        pptfile.SaveAs Left(ff.Path, InStrRev(ff.Path, &amp;#34;.&amp;#34;)) &amp;amp; &amp;#34;pdf&amp;#34;, 32, False
        pptfile.Close
        Set pptfile = Nothing
    End If
Next

&amp;#39; 清理对象
If Not oWord Is Nothing Then
    oWord.Quit
    Set oWord = Nothing
End If
If Not ppt Is Nothing Then
    ppt.Quit
    Set ppt = Nothing
End If

MsgBox &amp;#34;PPT和Word文件已成功转换为PDF格式！&amp;#34;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>【分子对接】1. 自动从pubchem下载小分子 脚本</title>
      <link>https://cywd123.github.io/old/posts/qin3ksdr8z/</link>
      <pubDate>Wed, 26 Mar 2025 20:25:40 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/qin3ksdr8z/</guid>
      <description>&lt;p&gt;本代码用于从pubchem下载小分子(阿司匹林)，并且自动转换成pymol的pdb格式&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import pubchempy as pcp
from pymol import cmd
import os
def download_sdf(compound_identifier, output_file):
    try:
        # 尝试根据标识符获取化合物
        if isinstance(compound_identifier, int):
            compound = pcp.Compound.from_cid(compound_identifier)
        else:
            results = pcp.get_compounds(compound_identifier, &amp;#39;name&amp;#39;)
            if results:
                compound = results[0]
            else:
                print(f&amp;#34;未找到与 {compound_identifier} 匹配的化合物。&amp;#34;)
                return

        # 下载 SDF 文件
        sdf_content = compound.canonical_smiles
        sdf = pcp.get_sdf(compound.cid)
        with open(output_file, &amp;#39;w&amp;#39;) as file:
            file.write(sdf)
        print(f&amp;#34;SDF 文件已成功保存到 {output_file}&amp;#34;)
    except Exception as e:
        print(f&amp;#34;下载过程中出现错误: {e}&amp;#34;)


if __name__ == &amp;#34;__main__&amp;#34;:
    # 这里可以替换为你想要查询的化合物名称或 CID
    compound_identifier = &amp;#34;aspirin&amp;#34;
    output_file = compound_identifier + &amp;#34;.sdf&amp;#34;
    download_sdf(compound_identifier, output_file)
    # 使用 PyMOL 加载 SDF 文件并进行后续处理
    cmd.load(output_file)
    # 保存为 PDB 文件（可选）
    cmd.save(compound_identifier + &amp;#34;.pdb&amp;#34;, state=0)
    cmd.quit()
    # 删除临时 SDF 文件（可选）
    #os.remove(output_file)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>问卷星自动填写脚本</title>
      <link>https://cywd123.github.io/old/posts/trgcxiotbs/</link>
      <pubDate>Sun, 23 Mar 2025 18:17:36 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/trgcxiotbs/</guid>
      <description>&lt;p&gt;2025年3月23日测试批量填写80份正常。&lt;/p&gt;
&lt;p&gt;需要模拟鼠标操作防止被识别机器人&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import re
from playwright.async_api import Playwright, async_playwright
#from playwright.sync_api import Playwright, sync_playwright, expect
import random

import asyncio
import time
def random_int(min=2, max=4):
    random.seed(time.time())    
    return str(random.randint(min, max))

async def mouse_random_move(page):
    # 模拟鼠标随机平滑移动
    for i in range(5):
        await page.mouse.move(random.randint(0, 1000), random.randint(0, 1000))
        await asyncio.sleep(0.1)
    # 模拟鼠标随机停留
    #time.sleep(random.randint(0,1))
    # 鼠标滚轮

async def run(browser) -&amp;gt; None:
    
    context = await browser.new_context()
    page = await context.new_page()
    await page.goto(&amp;#34;https://www.wjx.cn/vm/Q0x3Wuq.aspx&amp;#34;)
    await page.get_by_text(&amp;#34;男&amp;#34;).click()
    await page.get_by_text(&amp;#34;大三&amp;#34;).click()
    await page.get_by_text(&amp;#34;1000-&amp;#34;).click()
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^全部来自家庭部分来自家庭，部分靠自己赚取全部靠自己赚取$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^300以下300-600600-10001000以上$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^无1-200200-500500以上$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).nth(2).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^实体店网购$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).first.click()
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^100以下100-500500-10001000以上$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).nth(3).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^无200以下200-500500-10001000以上$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).nth(2).click()
    await page.locator(&amp;#34;#div10&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(2).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div11&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div12&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).first.click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div13&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div14&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(2).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div15&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div16&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(2).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div17&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div:nth-child(2) &amp;gt; .jqcheckwrapper &amp;gt; .jqcheck&amp;#34;).first.click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div:nth-child(5) &amp;gt; .jqcheckwrapper &amp;gt; .jqcheck&amp;#34;).first.click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div:nth-child(7) &amp;gt; .jqcheckwrapper &amp;gt; .jqcheck&amp;#34;).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div19&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(3).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div20&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div20&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).first.click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div21 &amp;gt; .ui-controlgroup &amp;gt; div:nth-child(2) &amp;gt; .jqcheckwrapper &amp;gt; .jqcheck&amp;#34;).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div21 &amp;gt; .ui-controlgroup &amp;gt; div:nth-child(4) &amp;gt; .jqcheckwrapper &amp;gt; .jqcheck&amp;#34;).click()
    await page.get_by_text(&amp;#34;提交&amp;#34;).click()
    await page.wait_for_function(&amp;#34;window.location.href !== &amp;#39;https://www.wjx.cn/vm/Q0x3Wuq.aspx&amp;#39;&amp;#34;)
    await page.wait_for_timeout(3000)
    await page.close()
    await context.close()

async def main() -&amp;gt; None:
    async with async_playwright() as p:
        browser = await  p.chromium.launch(headless=True)
        tasks = []
        for i in range(6):
            tasks.append(run(browser))
        titles=await asyncio.gather(*tasks)
        for title in titles:  
            print(title) 
        await browser.close()
        
if __name__ == &amp;#34;__main__&amp;#34;:
    asyncio.run(main())
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>EndNote/Zotero批量添加PubMed文献脚本</title>
      <link>https://cywd123.github.io/old/posts/7uduxw77v6/</link>
      <pubDate>Fri, 14 Mar 2025 21:10:48 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/7uduxw77v6/</guid>
      <description>&lt;p&gt;代理使用8089端口，适配clash&lt;br&gt;
使用：同目录下创建paper.txt，一行一个填写一个PMID&lt;br&gt;
生成一个citation.nbib格式的文件&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
# %%
###预处理，先把文章全部复制到一个paper.txt文本中
###先获取所有PMID: 后面的数字
import re
import pandas as pd
import numpy as np

proxies = {&amp;#34;http&amp;#34;: &amp;#34;http://127.0.0.1:8089&amp;#34;}

pm=pd.read_csv(&amp;#39;paper.txt&amp;#39;,header=None)
# to list
pm=pm[0].tolist()


# %%
import requests
from concurrent.futures import ThreadPoolExecutor

def fetch_pmid(pmid):
    max_retries = 300  # 设置最大重试次数
    for attempt in range(max_retries):
        url = &amp;#39;https://api.ncbi.nlm.nih.gov/lit/ctxp/v1/pubmed/?format=medline&amp;amp;id={}&amp;#39;.format(pmid)
        print(url)
        print(&amp;#34;-------requests start--------------&amp;#34;)
        res = requests.get(url,proxies=proxies)
        print(&amp;#34;-------requests end--------------&amp;#34;)
        print(res)
        if res.status_code == 200:
            res.close()
            return res.text + &amp;#34;\n&amp;#34;

        else:
            print(f&amp;#34;Request failed, retrying... (attempt {attempt + 1}/{max_retries})&amp;#34;)
    
    print(f&amp;#34;Failed to fetch PMID {pmid} after {max_retries} attempts.&amp;#34;)
    return &amp;#34;&amp;#34;

cita = []

# 设置线程数，这里设置为4，你可以根据需要调整
num_threads = 32

with ThreadPoolExecutor(max_workers=num_threads) as executor:
    # 使用多线程并行处理每个pmid
    results = list(executor.map(fetch_pmid, pm))

cita.extend(results)

# 替换处理

# %%
cita = [y.replace(&amp;#34;\r&amp;#34;, &amp;#34;&amp;#34;) for y in cita]
cita = [y + &amp;#34;\n&amp;#34; for y in cita]
f=open(&amp;#34;citation.nbib&amp;#34;,&amp;#34;w&amp;#34;,encoding=&amp;#39;utf-8&amp;#39;)
f.writelines(cita)
f.close()
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>使用Hyper-V配置网卡多个虚拟网卡</title>
      <link>https://cywd123.github.io/old/posts/kbg4hlog6b/</link>
      <pubDate>Fri, 14 Mar 2025 20:55:35 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/kbg4hlog6b/</guid>
      <description>&lt;h2 id=&#34;配置-hyper-v&#34;&gt;配置 Hyper-V&lt;/h2&gt;
&lt;p&gt;首先需要启用 Hyper-V，在 &lt;strong&gt;管理员 Powershell&lt;/strong&gt;输入以下命令：&lt;/p&gt;
&lt;p&gt;然后重启电脑。&lt;/p&gt;
&lt;h3 id=&#34;启用-hyper-v&#34;&gt;启用 Hyper-V&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;安装-hyper-v-虚拟交换机&#34;&gt;安装 Hyper-V 虚拟交换机&lt;/h3&gt;
&lt;p&gt;在管理员 Powershell 输入以下命令。name 参数后面的 Ethernet-Virt 是虚拟交换机的名称，可以任取。 NetAdapterName 参数后面的 Ethernet 代表你要桥接的物理网卡的名称，中文版系统一般为 以太网，英文版为 Ethernet。注意 AllowManagementOS 需要为 $false，否则 Hyper-V 会创建一个和物理网卡一样 MAC 地址的虚拟网卡妨碍我们使用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;New-VMSwitch -name Ethernet-Virt -AllowManagementOS $false  -NetAdapterName &amp;#34;以太网 2&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;向宿主机添加虚拟网卡&#34;&gt;向宿主机添加虚拟网卡&lt;/h3&gt;
&lt;p&gt;在管理员 Powershell 输入以下命令。Switch 参数后面的 Ethernet-Virt 是虚拟交换机的名称。 Name 参数后面的 Ethernet-Virt-Main 是虚拟网卡的名称，可以任取。注意要有 ManagementOS 参数，代表向宿主机添加网卡而不是某个虚拟机。StaticMacAddress 后面的 e0-00-00-00-ca-01 是虚拟网卡的 MAC 地址，可以任取，但必须唯一并且是单播地址（不懂单播、多播地址的话就无脑e0开头，然后后面的数字随便换）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Add-VMNetworkAdapter -Switch Ethernet-Virt -ManagementOS -Name &amp;#34;Ethernet-Virt-Main1&amp;#34; -StaticMacAddress 38:fd:cc:7c:94:c5
Add-VMNetworkAdapter -Switch Ethernet-Virt -ManagementOS -Name &amp;#34;Ethernet-Virt-Main2&amp;#34; -StaticMacAddress b0:36:c6:fa:f4:df
Add-VMNetworkAdapter -Switch Ethernet-Virt -ManagementOS -Name &amp;#34;Ethernet-Virt-Main3&amp;#34; -StaticMacAddress 90:53:84:3e:9b:12
Add-VMNetworkAdapter -Switch Ethernet-Virt -ManagementOS -Name &amp;#34;Ethernet-Virt-Main4&amp;#34; -StaticMacAddress 5c:1f:4b:eb:62:ad
Add-VMNetworkAdapter -Switch Ethernet-Virt -ManagementOS -Name &amp;#34;Ethernet-Virt-Main5&amp;#34; -StaticMacAddress 58:d3:b1:6b:f4:97
Add-VMNetworkAdapter -Switch Ethernet-Virt -ManagementOS -Name &amp;#34;Ethernet-Virt-Main6&amp;#34; -StaticMacAddress 18:9c:1a:d5:ca:a8
Add-VMNetworkAdapter -Switch Ethernet-Virt -ManagementOS -Name &amp;#34;Ethernet-Virt-Main7&amp;#34; -StaticMacAddress 54:7c:bd:16:ae:0a
Add-VMNetworkAdapter -Switch Ethernet-Virt -ManagementOS -Name &amp;#34;Ethernet-Virt-Main8&amp;#34; -StaticMacAddress d0:7c:6b:78:13:2f
Add-VMNetworkAdapter -Switch Ethernet-Virt -ManagementOS -Name &amp;#34;Ethernet-Virt-Main9&amp;#34; -StaticMacAddress a0:05:1c:48:0b:12
Add-VMNetworkAdapter -Switch Ethernet-Virt -ManagementOS -Name &amp;#34;Ethernet-Virt-Main10&amp;#34; -StaticMacAddress ec:89:10:ac:20:97
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用结束删除虚拟交换机-confirm--a&#34;&gt;使用结束，删除虚拟交换机： Confirm : A&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Remove-VMSwitch -name Ethernet-Virt -Force -Confirm
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>python 利用curl将全部网卡适配器登录STU校园网</title>
      <link>https://cywd123.github.io/old/posts/byprsldhih/</link>
      <pubDate>Fri, 14 Mar 2025 20:49:01 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/byprsldhih/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import netifaces
import os
# 获取所有网络接口
interfaces = netifaces.interfaces()

for iface in interfaces:
    # 获取接口的地址信息
    addresses = netifaces.ifaddresses(iface)
    # 提取 IPv4 地址
    if netifaces.AF_INET in addresses:
        for addr_info in addresses[netifaces.AF_INET]:
            ip = addr_info.get(&amp;#39;addr&amp;#39;)
            if ip:
                print(f&amp;#34;适配器 {iface} 的IP地址: {ip}&amp;#34;)
                os.system(&amp;#39;curl --data &amp;#34;opr=pwdLogin&amp;amp;userName=账号&amp;amp;pwd=密码&amp;amp;rememberPwd=1&amp;#34; http://1.1.1.2/ac_portal/login.php  --interface &amp;#39; + ip)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>snakemake流程——SMR&#43;MR&#43;MAGMA分析</title>
      <link>https://cywd123.github.io/old/posts/vw5dv077fn/</link>
      <pubDate>Fri, 14 Mar 2025 20:46:52 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/vw5dv077fn/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
# 定义染色体列表，包含 1 到 22 号染色体
chromosomes = list(range(1, 23))

# 获取组学暴露数据文件的名称
(MRname,) = glob_wildcards(&amp;#34;../dataset/组学暴露数据/{file}.rds&amp;#34;)

# 获取 SMR 数据文件的名称
GTExname = glob_wildcards(&amp;#34;../dataset/SMR/{file}.besd&amp;#34;).file

# 获取 GWAS 数据文件的名称
GWASfilename = glob_wildcards(&amp;#34;../../SMR/input/{file}&amp;#34;).file

# 定义 all 规则，用于指定整个流程的最终输出文件
rule all:
    input:
        expand(&amp;#34;result/GTEx的{GTEx}之{file}.smr&amp;#34;, GTEx=GTExname, file=GWASfilename),
        #expand(&amp;#34;result/MR的{file}之{MR}.csv&amp;#34;, MR=MRname, file=GWASfilename),
        expand(&amp;#34;result/{file}.gsa.out.txt&amp;#34;,file=GWASfilename),
        #expand(&amp;#34;result/Gene_disease_association/{file}.fusion_twas.txt&amp;#34;,file=GWASfilename),  #TWAS 若全部49个组织非常慢10小时
        

# 定义 trans 规则，用于将输入文件转换为输出文件
rule trans:   #OK
    input:
        # 输入文件路径
        &amp;#34;../../SMR/input/{file}&amp;#34;
    output:
        # 输出文件路径
        &amp;#34;tmp/{file}.ma&amp;#34;,
        &amp;#34;tmp/{file}.sumstats.gz&amp;#34;,
        &amp;#34;tmp/{file}.mendelR.txt&amp;#34;
    # 规则执行时使用的线程数
    threads: 6
    shell:
        # 调用 R 脚本进行文件转换
        &amp;#34;r -f tools/trans.R --args {wildcards.file}&amp;#34;    

rule run_GTEx:  #OK
    input:
        &amp;#34;tmp/{file}.ma&amp;#34;,
    output:
        &amp;#34;result/GTEx的{GTEx}之{file}.smr&amp;#34;
    threads: 5
    shell:
        &amp;#34;tools\\smr.exe --gwas-summary  {input}  --out  result/GTEx的{wildcards.GTEx}之{wildcards.file}  --bfile ../dataset/EUR --beqtl-summary ../dataset/SMR/{wildcards.GTEx} --maf 0.01 --thread-num 18 --diff-freq-prop 1.000000&amp;#34;

rule run_MAGMA:  #OK
    input:
        &amp;#34;tmp/{file}.ma&amp;#34;,
    output:
        &amp;#34;result/{file}.gsa.out.txt&amp;#34;,
    shell:
        &amp;#34;r -f tools/run_MAGMA.R --args {wildcards.file}&amp;#34;
        
rule run_MR:  #OK
    input:
        &amp;#34;tmp/{file}.ma&amp;#34;,
    output:
        &amp;#34;result/MR的{file}之{MR}.csv&amp;#34;,
    threads: 2
    shell:
        &amp;#34;r -f tools/run_MR.R --args {wildcards.file} {wildcards.MR}&amp;#34;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>playwright自动登录STU WebVPN</title>
      <link>https://cywd123.github.io/old/posts/st6eftek36/</link>
      <pubDate>Tue, 11 Mar 2025 09:55:00 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/st6eftek36/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
import re
from playwright.sync_api import Playwright, sync_playwright, expect
import time
import os

import hmac
import hashlib

def totp(key, t, digits=6):
    step = 30
    t = int(t / step)
    key = key.encode()
    counter = t.to_bytes(8, &amp;#39;big&amp;#39;)
    h = hmac.new(key, counter, hashlib.sha1).digest()
    offset = h[-1] &amp;amp; 0x0f
    truncated = h[offset:offset + 4]
    code = int.from_bytes(truncated, &amp;#39;big&amp;#39;) &amp;amp; 0x7fffffff
    code = str(code % 10 ** digits).zfill(digits)
    return code

# %%


def run(playwright: Playwright) -&amp;gt; None:
    browser = playwright.chromium.launch(headless=True)
    context = browser.new_context()
    page = context.new_page()
    page.goto(&amp;#34;https://webvpn.stu.edu.cn/portal/#!/login&amp;#34;)
    page.locator(&amp;#34;#Calc input[type=\&amp;#34;text\&amp;#34;]&amp;#34;).fill(&amp;#34;校园网账号&amp;#34;)
    page.locator(&amp;#34;#loginPwd&amp;#34;).click()
    page.locator(&amp;#34;#loginPwd&amp;#34;).fill(&amp;#34;校园网密码&amp;#34;)
    page.locator(&amp;#34;span&amp;#34;).filter(has_text=&amp;#34;我已阅读并同意&amp;#34;).locator(&amp;#34;div&amp;#34;).first.click()
    page.get_by_role(&amp;#34;button&amp;#34;, name=&amp;#34;登录&amp;#34;).click()
    page.locator(&amp;#34;#app_dialog_container&amp;#34;).get_by_role(&amp;#34;textbox&amp;#34;).fill(str(totp(&amp;#34;填写你的TOTP密钥&amp;#34;, time.time())))
    page.get_by_role(&amp;#34;button&amp;#34;, name=&amp;#34;确定&amp;#34;).click()
    # ---------------------
    # 获取cookie值
    cookies = page.context.cookies()
    for cookie in cookies:
        print(f&amp;#34;{cookie[&amp;#39;name&amp;#39;]}: {cookie[&amp;#39;value&amp;#39;]}&amp;#34;)
        if cookie[&amp;#39;name&amp;#39;] == &amp;#34;TWFID&amp;#34;:
            TWFID = cookie[&amp;#39;value&amp;#39;]
    
    
    url=&amp;#34;https://webvpn.stu.edu.cn/portal/shortcut.html?twfid=&amp;#34;+TWFID+&amp;#34;&amp;amp;url=http://bilibili-com-s.webvpn.stu.edu.cn%3A8118&amp;#34;
    os.system(&amp;#39;start msedge &amp;#34;&amp;#39;+url+&amp;#39;&amp;#34;&amp;#39;)
    # ---------------------
    context.close()
    browser.close()


with sync_playwright() as playwright:
    run(playwright)

    
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>ECDSA实例</title>
      <link>https://cywd123.github.io/old/posts/22bskm0nwq/</link>
      <pubDate>Tue, 11 Mar 2025 01:05:02 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/22bskm0nwq/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
import os
import ecdsa

# 生成私钥和公钥
def generate_keys():
    # 使用secp256k1曲线生成密钥对
    sk = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1)
    vk = sk.get_verifying_key()
    return sk, vk

# 对消息进行签名
def sign_message(private_key, message):
    return private_key.sign(message)

# 验证签名
def verify_signature(public_key, message, signature):
    return public_key.verify(signature, message)

# %%
private_key, public_key = generate_keys()
# 简单消息
message = b&amp;#34;Hello, ECDSA!&amp;#34;

# 签名消息
signature = sign_message(private_key, message)
print(f&amp;#34;Signature: {signature.hex()}&amp;#34;)


# %% 
sig=&amp;#39;adee313bebf78c1bd4a9719e0ad9aa871ff8195788ad2d7510f35e1ef0ce00a6cbfea518e4ea1716a729c7313a52da8b0c57ff0e0f97251ea604beef3890f699&amp;#39;
message = b&amp;#34;Hello, ECDSA!&amp;#34;
signature = bytes.fromhex(sig)
print(verify_signature(public_key, message, signature))   #验证签名
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>汕头大学SSO 单点登录接入实例</title>
      <link>https://cywd123.github.io/old/posts/40qvh8raw6/</link>
      <pubDate>Tue, 11 Mar 2025 01:00:18 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/40qvh8raw6/</guid>
      <description>&lt;p&gt;Single Sign On System&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import os
url=&amp;#34;https://sso.stu.edu.cn/login?service=http://localhost:8080&amp;#34;
os.system(&amp;#39;start msedge &amp;#34;&amp;#39;+url+&amp;#39;&amp;#34;&amp;#39;)

import http.server
import socketserver
import urllib.parse
import threading
import requests
import xml.etree.ElementTree as ET
import warnings
warnings.filterwarnings(&amp;#34;ignore&amp;#34;)

# 定义全局变量存储ticket
ticket = None
username = None
# 自定义请求处理类
class MyHandler(http.server.SimpleHTTPRequestHandler):
    def log_message(self, format, *args):
        pass  # 重写方法，不执行任何操作

    def do_GET(self):
        global ticket, httpd, username
        # 解析请求路径的参数
        parsed_path = urllib.parse.urlparse(self.path)
        query_params = urllib.parse.parse_qs(parsed_path.query)
        
        # 检查是否存在ticket参数
        if &amp;#39;ticket&amp;#39; in query_params:
            ticket = query_params[&amp;#39;ticket&amp;#39;][0]
        
        # 发送响应
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b&amp;#34;Ticket received...&amp;#34;)
        vurl=&amp;#34;https://sso.stu.edu.cn/serviceValidate?service=http://localhost:8080&amp;amp;ticket=&amp;#34;+ticket
        headers={&amp;#39;Connection&amp;#39;:&amp;#39;close&amp;#39;}
        requests.adapters.DEFAULT_RETRIES = 5
        response = requests.get(vurl, headers=headers, verify=False)
        root = ET.fromstring(response.text)
        if root[0].tag.endswith(&amp;#39;authenticationSuccess&amp;#39;):
            print(&amp;#39;Login success, you can close the browser now 登陆成功，您可以关闭浏览器了&amp;#39;)
            print(&amp;#39;username:&amp;#39;, root[0][0].text)
            username = root[0][0].text
            response.close()
            threading.Thread(target=httpd.shutdown).start()
        else:
            print(&amp;#39;Login failed, please try again 登陆失败，请重试&amp;#39;)
            print(&amp;#39;error:&amp;#39;, root[0][0].text)
        # 关闭服务器
# 启动服务器
def run_server():
    global httpd
    port = 8080
    handler = MyHandler
    with socketserver.TCPServer((&amp;#34;&amp;#34;, port), handler) as httpd:
        print(f&amp;#34;Verifying login at https://sso.stu.edu.cn/login?service=http://localhost:8080&amp;#34;)
        httpd.serve_forever()
run_server()


Users =[&amp;#39;用户名&amp;#39;]

if username in Users:
    print(&amp;#39;Login success, welcome to use this script 登陆成功，欢迎使用本脚本&amp;#39;)
else:
    print(&amp;#39;No permission to use this script 没有权限使用本脚本&amp;#39;)
    os.system(&amp;#39;pause&amp;#39;)
    exit()
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>STU校园网自动登录脚本</title>
      <link>https://cywd123.github.io/old/posts/htt13gbuie/</link>
      <pubDate>Tue, 11 Mar 2025 00:52:49 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/htt13gbuie/</guid>
      <description>&lt;p&gt;cmd, ???处分别改称用户名和校园网密码&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
@ECHO OFF
REM 启动延时变量
setlocal enabledelayedexpansion
:LoginCheck
for /F %%i in ( &amp;#39;curl -I -m 10 -o /dev/null -s -w %%{http_code} www.baidu.com&amp;#39; ) do ( set http_code=%%i )
if /i %http_code% neq 200 (
	curl --data &amp;#34;opr=pwdLogin&amp;amp;userName=???&amp;amp;pwd=???&amp;amp;rememberPwd=1&amp;#34; http://1.1.1.2/ac_portal/login.php&amp;gt;result.txt	
	set /p result=&amp;lt;result.txt
	set result=!result:~11,4!
	if !result! equ true (
		echo Login Success
	) else (
		echo Login Failed, Try Again
		choice /t 10 /d y /n &amp;gt;nul
		goto LoginCheck
	)
	del result.txt
)
endlocal
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>vbs脚本 快速将ppt word文档转换成pdf</title>
      <link>https://cywd123.github.io/old/posts/92gfku-5zk/</link>
      <pubDate>Tue, 11 Mar 2025 00:48:44 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/92gfku-5zk/</guid>
      <description>&lt;p&gt;保存为vbs脚本，可以将同目录下的ppt、word转成PDF，非常方便&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;On Error Resume Next
    Const wdExportFormatPDF = 17
    Set oWord = WScript.CreateObject(&amp;#34;Word.Application&amp;#34;)
	Set ppt = CreateObject(&amp;#34;PowerPoint.application&amp;#34;)
    Set fso = WScript.CreateObject(&amp;#34;Scripting.Filesystemobject&amp;#34;)
    Set fds=fso.GetFolder(&amp;#34;.&amp;#34;)
    Set ffs=fds.Files
	
    For Each ff In ffs
    If (LCase(Right(ff.Name,4))=&amp;#34;.doc&amp;#34; Or LCase(Right(ff.Name,4))=&amp;#34;docx&amp;#34; ) And Left(ff.Name,1)&amp;lt;&amp;gt;&amp;#34;~&amp;#34; Then
        Set oDoc=oWord.Documents.Open(ff.Path)
        odoc.ExportAsFixedFormat Left(ff.Path,InStrRev(ff.Path,&amp;#34;.&amp;#34;))&amp;amp;&amp;#34;pdf&amp;#34;,wdExportFormatPDF
    End If
	If (LCase(Right(ff.Name,4))=&amp;#34;.ppt&amp;#34; Or LCase(Right(ff.Name,4))=&amp;#34;pptx&amp;#34; ) And Left(ff.Name,1)&amp;lt;&amp;gt;&amp;#34;~&amp;#34; Then
Set pptfile = ppt.Presentations.Open(ff.Path,false,false,false)
pptfile.Saveas Left(ff.Path,InStrRev(ff.Path,&amp;#34;.&amp;#34;))&amp;amp;&amp;#34;pdf&amp;#34;,32,false
End If
    Next
    odoc.Close
    oword.Quit
	pptfiles.Close
	ppt.Quit
    Set oDoc=Nothing
    Set oWord =Nothing
	Set pptfile = Nothing
	Set ppt = Nothing
	MsgBox &amp;#34;PPT和Word全部转换为PDF啦!&amp;#34;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>雨课堂习题监控</title>
      <link>https://cywd123.github.io/old/posts/pbdbfbga9g/</link>
      <pubDate>Tue, 11 Mar 2025 00:41:06 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/pbdbfbga9g/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;原理：雨课堂每次切换PPT时url也会跟着改变。在检测到ppt切换后，获取ppt的图片，并且进行OCR检测，如果出现‘单选’、‘多选’、‘判断’、‘填空’、‘投票’等词汇，就认定该ppt是习题，就会发出警告提醒。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用前需要配置state.json保存登录记录。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import asyncio
from playwright.async_api import async_playwright
import requests
import threading
import winsound
from plyer import notification
import easyocr
url=&amp;#34;&amp;#34;
# 初始化 EasyOCR
reader = easyocr.Reader([&amp;#39;ch_sim&amp;#39;, &amp;#39;en&amp;#39;])

async def notice_ti(page):
    # 尝试查找图片元素
    elementimg = await page.query_selector_all(&amp;#39;//*[@id=&amp;#34;app&amp;#34;]/section/section[1]/section[2]/section/section/section/section[1]/section/div/section/section/img&amp;#39;)
    if len(elementimg) == 0:
        elementimg = await page.query_selector_all(&amp;#39;//*[@id=&amp;#34;app&amp;#34;]/section/section[1]/section[2]/section/section/section/section[1]/section/section/section/section/img&amp;#39;)

    # 发送新页面通知
    notification.notify(title=&amp;#39;新的一页&amp;#39;, message=&amp;#39;新的一页&amp;#39;, app_icon=None, timeout=0.5)

    if elementimg:
        # 获取图片地址
        img_url = await elementimg[0].get_attribute(&amp;#39;src&amp;#39;)
        # 直接下载图片
        tmp = requests.get(img_url)
        with open(&amp;#39;tmp.png&amp;#39;, &amp;#39;wb&amp;#39;) as f:
            f.write(tmp.content)

        # 使用 EasyOCR 识别图片文字
        result = reader.readtext(&amp;#39;tmp.png&amp;#39;)
        # 如果 result 中含有‘单选’、‘多选’、‘判断’、‘填空’、‘投票’、‘问答’、‘作业’、‘讨论’、‘实验’、‘课件’、‘课程’、‘提交’等关键词，就发送通知
        keywords = [&amp;#39;单选&amp;#39;, &amp;#39;多选&amp;#39;, &amp;#39;判断&amp;#39;, &amp;#39;填空&amp;#39;, &amp;#39;投票&amp;#39;, &amp;#39;问答&amp;#39;, &amp;#39;作业&amp;#39;, &amp;#39;讨论&amp;#39;, &amp;#39;实验&amp;#39;, &amp;#39;提交&amp;#39;]
        #keywords = [&amp;#39;电解&amp;#39;]
        if any(x in str(result) for x in keywords):
            print(img_url)
            threading.Thread(target=lambda: winsound.Beep(440, 3000)).start()
            notification.notify(title=&amp;#39;有题！&amp;#39;, message=&amp;#39;有题！&amp;#39;, app_icon=None, timeout=0.5)
            # ai(result)
            # clear_page()

async def main():
    async with async_playwright() as p:
        # 配置浏览器选项
        browser = await p.chromium.launch(headless=True)
        context = await browser.new_context(storage_state=&amp;#39;state.json&amp;#39;)
        page = await context.new_page()
        # 打开指定页面
        await page.goto(url)

        current_url = page.url
        while True:
            # 等待 URL 变化
            await page.wait_for_url(lambda url: url != current_url, timeout=10000000)
            current_url = page.url
            await notice_ti(page)
            #await print(&amp;#34;已到达新页面&amp;#34;)

if __name__ == &amp;#34;__main__&amp;#34;:
    url=input(&amp;#34;请输入网址：&amp;#34;)
    asyncio.run(main())
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>zkw线段树</title>
      <link>https://cywd123.github.io/old/posts/uljgqekoo3/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:55 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/uljgqekoo3/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int d[500000*4],n,m=1;


inline void build(int n){
	while(m&amp;lt;=n)m&amp;lt;&amp;lt;=1;
    for(int i=m+1;i&amp;lt;=m+n;i++) cin&amp;gt;&amp;gt;d[i];
    for(int i=m-1;i;--i) d[i]=d[i&amp;lt;&amp;lt;1]+d[i&amp;lt;&amp;lt;1|1]; 
}  

void chg(int x,int v){
    d[x=m+x]+=v;
    while(x) d[x&amp;gt;&amp;gt;=1]=d[x&amp;lt;&amp;lt;1]+d[x&amp;lt;&amp;lt;1|1];
}  

int add(int x,int v){
	for(int i=x+m;i;i&amp;gt;&amp;gt;=1)d[i]+=v;
}
int ask(int l,int r){
int ans=0;
for(l=m+l-1,r=m+r+1 ; l^r^1 ; l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1){
	if(~l&amp;amp;1)ans+=d[l^1];
if(r&amp;amp;1)ans+=d[r^1];
}
return ans;
}
void debug(){
	for(int i=m+1;i&amp;lt;=m+n;i++)cout&amp;lt;&amp;lt;d[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;;
	cout&amp;lt;&amp;lt;m&amp;lt;&amp;lt;endl;
	
}
int main(){
int q;
cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;q;
build(n);
while(q--){
	int op,a,b;
	cin&amp;gt;&amp;gt;op&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
	if(op==1)add(a,b);
	else cout&amp;lt;&amp;lt;ask(a,b)&amp;lt;&amp;lt;endl;
}


} 
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>ST表</title>
      <link>https://cywd123.github.io/old/posts/6jfataceqh/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:40 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/6jfataceqh/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int f[2000010][24],n;
int get(int x,int y){
	int k=log(y-x+1)/log(2);
	return max(f[x][k],f[y-(1&amp;lt;&amp;lt;k)+1][k]);
}
int main(){
	int i,j,m,t,k;
	scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;n,&amp;amp;m);
	for(i=1;i&amp;lt;=n;i++)
	scanf(&amp;#34;%d&amp;#34;,&amp;amp;f[i][0]);
	int x=log(n)/log(2)+1;
	for(int j=1;j&amp;lt;x;j++)
	for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)
	f[i][j]=max(f[i][j-1],f[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
	while(m--){
		int a,b;
		scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a,&amp;amp;b);
		printf(&amp;#34;%d\n&amp;#34;,get(a,b));
		
		
	}

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>SPFA算法</title>
      <link>https://cywd123.github.io/old/posts/ldovg2gc2p/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:27 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/ldovg2gc2p/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const long long   N=100010,M=200011;
long long   head[N],ver[M],edge[M],Next[M],d[N];
long long   n,m,tot=0;
queue&amp;lt;long long &amp;gt;q;
bool v[N];
void add(long long   x,long long   y,long long   z){
	ver[++tot]=y;edge[tot]=z;Next[tot]=head[x];
	head[x]=tot;
}
int main(){
long long   i,j,n,m,a,b,c,s;
scanf(&amp;#34;%lld %lld %lld&amp;#34;,&amp;amp;n,&amp;amp;m,&amp;amp;s);
while(m--){
scanf(&amp;#34;%lld %lld %lld&amp;#34;,&amp;amp;a,&amp;amp;b,&amp;amp;c);
add(a,b,c);
//	add(b,a,c);
}
memset(d,0x3f,sizeof(d));
memset(v,0,sizeof(v));
d[s]=0;
v[s]=1;
q.push(1);
while(q.size())
{
	long long   x=q.front();
	q.pop();
	v[x]=0;
	for(long long  i=head[x];i;i=Next[i])
	{long long   y=ver[i],z=edge[i];
	if(d[y]&amp;gt;d[x]+z){
		d[y]=d[x]+z;
		if(!v[y])
		{
			q.push(y);
			v[y]=1;
			
		}
	}
	}
	
	
}


for(i=1;i&amp;lt;=n;i++)
cout&amp;lt;&amp;lt;d[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;;


}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Prim算法</title>
      <link>https://cywd123.github.io/old/posts/f481dm04tj/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:15 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/f481dm04tj/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef int ll;

ll d[5010],mp[5010][5010];
bool v[5010];
ll i,j,n,m,t,k;

int main() {
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
	memset(mp,0x3f,sizeof(mp));
	memset(d,0x3f,sizeof(d));
	memset(v,0,sizeof(v));
	ll a,b,c;

	for(i=1; i&amp;lt;=m; i++) {
		cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;

		mp[a][b]=min(mp[a][b],c);

		mp[b][a]=mp[a][b];

	}

	d[1]=0;

	for(i=1; i&amp;lt;n; i++) {
		ll x=0;
		for(j=1; j&amp;lt;=n; j++)

			if(!v[j]&amp;amp;&amp;amp;(x==0||d[j]&amp;lt;d[x]))x=j;

		v[x]=1;
		for(j=1; j&amp;lt;=n; j++)

			if(!v[j])d[j]=min(d[j],mp[x][j]);

	}

	ll ans=0;
	for(i=2; i&amp;lt;=n; i++)
		ans+=d[i];
	
	if(ans&amp;gt;99999999)cout&amp;lt;&amp;lt;&amp;#34;orz&amp;#34;;
	else cout&amp;lt;&amp;lt;ans;
	
	
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Prim堆优化版</title>
      <link>https://cywd123.github.io/old/posts/ibw-bmba9u/</link>
      <pubDate>Mon, 10 Mar 2025 13:27:52 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/ibw-bmba9u/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
priority_queue&amp;lt;pair&amp;lt;long long,long long&amp;gt; &amp;gt;q;
vector&amp;lt;long long&amp;gt;ver[5010],edge[5010];
bool v[5010];
long long d[5010];
long long n,m;
void add(long long x,long long y,long long z){
	ver[x].push_back(y);edge[x].push_back(z);
}
void init(){
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
	for(long long i=1;i&amp;lt;=m;i++){
		long long a,b,c;
		cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
		add(a,b,c);add(b,a,c);
	}
}

void work(){
	memset(d,0x3f,sizeof(d));
	memset(v,0,sizeof(v));
	long long ans=0;
	d[1]=0;
	q.push(make_pair(0,1));
	int cnt=0;
	while(q.size()){
		long long x=q.top().second;
		q.pop();
		if(v[x])continue;
		v[x]=1;
		cnt++;
		for(int i=ver[x].size()-1;i&amp;gt;=0;i--){
		
			int y=ver[x][i],z=edge[x][i];
			if(!v[y] &amp;amp;&amp;amp;(z&amp;lt;d[y])){
				d[y]=z;
				q.push(make_pair(-d[y],y));
			}
		}
		
		
	}
for(int i=2;i&amp;lt;=n;i++)ans+=d[i];
if(cnt==n)cout&amp;lt;&amp;lt;ans;
else cout&amp;lt;&amp;lt;&amp;#34;orz&amp;#34;;


}

int main(){
init();
work();

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>LCA算法</title>
      <link>https://cywd123.github.io/old/posts/5ipfk_eghq/</link>
      <pubDate>Mon, 10 Mar 2025 13:27:39 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/5ipfk_eghq/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// luogu-judger-enable-o2
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int ver[2*500000],nex[2*500000],head[2*500000],d[2*500000],p[2*500000][23],tot;
void add(int x,int y){
	ver[++tot]=y;nex[tot]=head[x];head[x]=tot;
}
int read(){
	int x=0;
	char ch;
	while(ch&amp;lt;&amp;#39;0&amp;#39;||ch&amp;gt;&amp;#39;9&amp;#39;)ch=getchar();
	while(ch&amp;gt;&amp;#39;0&amp;#39;&amp;amp;&amp;amp;ch&amp;lt;&amp;#39;9&amp;#39;){
		x=x*10+ch-&amp;#39;0&amp;#39;;
		ch=getchar();
	}
	return x;
}
void dfs(int x,int fa){
	d[x]=d[fa]+1;
	p[x][0]=fa;
	for(int i=1;(1&amp;lt;&amp;lt;i)&amp;lt;=d[x];i++)
	p[x][i]=p[p[x][i-1]][i-1];
	for(int i=head[x];i;i=nex[i]){
		if(ver[i]!=fa)
		dfs(ver[i],x);	
	}
}
int lca(int a,int b){
	if(d[a]&amp;gt;d[b])swap(a,b);
	for(int i=20;i&amp;gt;=0;i--)
	if(d[a]&amp;lt;=d[b]-(1&amp;lt;&amp;lt;i))
	b=p[b][i];
	if(a==b)
	return a;
	for(int i=20;i&amp;gt;=0;i--)
	if(p[a][i]==p[b][i])continue;
	else a=p[a][i],b=p[b][i];
	
	return p[a][0];
}
int main(){
	int i,j,n,m,t,k,s;
	scanf(&amp;#34;%d %d %d&amp;#34;,&amp;amp;n,&amp;amp;m,&amp;amp;s);
	for(int i=1;i&amp;lt;n;i++)
	{
		int a,b;
		scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a,&amp;amp;b);
		add(a,b);
		add(b,a);
	}
	dfs(s,0);
	for(i=1;i&amp;lt;=m;i++)
	{
		int a,b;
	scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a,&amp;amp;b);
		cout&amp;lt;&amp;lt;lca(a,b)&amp;lt;&amp;lt;endl;
	}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>匈牙利算法</title>
      <link>https://cywd123.github.io/old/posts/rnbllzkklq/</link>
      <pubDate>Mon, 10 Mar 2025 13:27:28 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/rnbllzkklq/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
bool ver[1001][1001],v[1001];
int d[1001],n,m,e;
bool dfs(int x){
	for(int i=1;i&amp;lt;=m;i++){
	if(ver[x][i]&amp;amp;&amp;amp;!v[i]){
		v[i]=1;
		if(!d[i]||dfs(d[i])){
			d[i]=x;return 1;
		}
		
	}

	}
	return 0;
}
void init(){
cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;e;
for(int i=1;i&amp;lt;=e;i++){
	int a,b;
	cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
	if(b&amp;gt;m||a&amp;gt;n)continue;
	ver[a][b]=1;

}
	int ans=0;
	for(int i=1;i&amp;lt;=n;i++){memset(v,0,sizeof(v));
	ans+=dfs(i);
	}
	cout&amp;lt;&amp;lt;ans;
}
int main(){
init();
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>线段树</title>
      <link>https://cywd123.github.io/old/posts/cse8xfl8mp/</link>
      <pubDate>Mon, 10 Mar 2025 13:26:55 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/cse8xfl8mp/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
struct pl{
	long long l,r,v,add,tim;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define v(x) tree[x].v
	#define add(x) tree[x].add
}tree[4*100000];
long long a[100001];
void build(long long p,long long l,long long r){
	l(p)=l;r(p)=r;
	if(l==r){
		v(p)=a[l];return;
	}
	long long mid=(l+r)&amp;gt;&amp;gt;1;
	build(p&amp;lt;&amp;lt;1,l,mid);
	build((p&amp;lt;&amp;lt;1)+1,mid+1,r);
	v(p)=v(p*2)+v(p*2+1);
}
void spread(long long p){
	if(add(p)==0)return;
	v(p*2)+=add(p)*(r(p*2)-l(p*2)+1);
	v(p*2+1)+=add(p)*(r(p*2+1)-l(p*2+1)+1);
	add(p*2)+=add(p);
	add(p*2+1)+=add(p);
	add(p)=0;
}
void chg(long long p,long long l,long long r,long long d){
	if(l&amp;lt;=l(p)&amp;amp;&amp;amp;r&amp;gt;=r(p)){
		v(p)+=d*(r(p)-l(p)+1);
		add(p)+=d;
		return;
	}
	spread(p);
	long long mid=(l(p)+r(p))&amp;gt;&amp;gt;1;
	if(l&amp;lt;=mid)chg(p*2,l,r,d);
	if(r&amp;gt;mid)chg(p*2+1,l,r,d);
	v(p)=v(p*2)+v(p*2+1);
}
long long ask(long long p,long long l,long long r){
	if(l&amp;lt;=l(p)&amp;amp;&amp;amp;r&amp;gt;=r(p))return v(p);
	spread(p);
	long long mid=(l(p)+r(p))&amp;gt;&amp;gt;1;
	long long ans=0;
	if(l&amp;lt;=mid)ans+=ask(p*2,l,r);
	if(r&amp;gt;mid)ans+=ask(p*2+1,l,r);
	return ans;
}
int main(){
long long i,j,n,m,t,k;
cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
for(i=1;i&amp;lt;=n;i++)cin&amp;gt;&amp;gt;a[i];
build(1,1,n);
while(m--){
	long long op,l,r,k;
	cin&amp;gt;&amp;gt;op&amp;gt;&amp;gt;l&amp;gt;&amp;gt;r;
	if(op==1){
		cin&amp;gt;&amp;gt;k;
		chg(1,l,r,k);
	}else cout&amp;lt;&amp;lt;ask(1,l,r)&amp;lt;&amp;lt;endl;	
}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>树状数组</title>
      <link>https://cywd123.github.io/old/posts/hl1binzfbh/</link>
      <pubDate>Mon, 10 Mar 2025 13:26:42 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/hl1binzfbh/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
long long c[500001];
	long long i,j,n,m,t,k;
long long lb(long long x)
{return x&amp;amp;(-x);
}
long long get(long long x)
{
	long long ans=0;
	for(;x;x-=lb(x))
	ans+=c[x];
	return ans;
}
void add(long long x,long long y){
	for(long long i=x;i&amp;lt;=n;i+=lb(i))
	c[i]+=y;
	
}

int main(){

	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
	for(i=1;i&amp;lt;=n;i++)
	{scanf(&amp;#34;%lld&amp;#34;,&amp;amp;t);
	add(i,t);
	}
	while(m--){
		cin&amp;gt;&amp;gt;t;
		if(t==1){
			cin&amp;gt;&amp;gt;j&amp;gt;&amp;gt;k;
			add(j,k);
		}
		else {
			
			cin&amp;gt;&amp;gt;j&amp;gt;&amp;gt;k;
			cout&amp;lt;&amp;lt;get(k)-get(j-1)&amp;lt;&amp;lt;endl;
		}
		
	}
	
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>kruskal算法（克鲁斯卡尔算法）</title>
      <link>https://cywd123.github.io/old/posts/y1ekvamzmi/</link>
      <pubDate>Mon, 10 Mar 2025 13:26:19 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/y1ekvamzmi/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define ll long long
using namespace std;
ll fa[5010];
ll get(ll x) {
	return x==fa[x]?x:fa[x]=get(fa[x]);
}
void mrg(ll a,ll b) {
fa[get(a)]=get(b);
}
struct pl{
	ll x,y,z;
	bool operator&amp;lt;(const pl &amp;amp;a){
	return z&amp;lt;a.z;
	}
}mp[200001];
int main() {
ll i,j,n,m,t=0,k=0;
cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
for(i=1;i&amp;lt;=m;i++)
{
	cin&amp;gt;&amp;gt;mp[i].x&amp;gt;&amp;gt;mp[i].y&amp;gt;&amp;gt;mp[i].z;
}
sort(mp+1,mp+1+m);
for(i=1;i&amp;lt;=n;i++)fa[i]=i;
for(i=1;i&amp;lt;=m&amp;amp;&amp;amp;t&amp;lt;n;i++){
	if(get(mp[i].x)!=get(mp[i].y))mrg(mp[i].x,mp[i].y),t++,k+=mp[i].z;	
}
if(t==n-1)
cout&amp;lt;&amp;lt;k;
else cout&amp;lt;&amp;lt;&amp;#34;orz&amp;#34;;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>带lazy标记的zkw线段树</title>
      <link>https://cywd123.github.io/old/posts/wwlgapb2j1/</link>
      <pubDate>Mon, 10 Mar 2025 13:25:58 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/wwlgapb2j1/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
long long d[500000&amp;lt;&amp;lt;2],laz[500000&amp;lt;&amp;lt;2],n,m=1;;
void build(){
	while(m&amp;lt;=n)m&amp;lt;&amp;lt;=1;
	for(long long i=m+1;i&amp;lt;=m+n;i++)cin&amp;gt;&amp;gt;d[i];
	for(long long i=m-1;i&amp;gt;=1;i--)d[i]=d[i&amp;lt;&amp;lt;1]+d[i&amp;lt;&amp;lt;1|1];
}
long long get(long long x,long long y){
	long long ans=0,lc=0,rc=0,cnt=1;//cnt=1
	for(x+=m-1,y+=m+1; x^y^1; x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1,cnt&amp;lt;&amp;lt;=1){
		if(laz[x])ans+=laz[x]*lc;
		if(laz[y])ans+=laz[y]*rc;
		if(~x&amp;amp;1)ans+=d[x^1],lc+=cnt;
		if(y&amp;amp;1)ans+=d[y^1],rc+=cnt;
	}
	
		for(;x;x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1)ans+=laz[x]*lc,ans+=laz[y]*rc;
	return ans;
}
void add(long long x,long long y,long long v){
	long long ans=0,lc=0,rc=0,cnt=1;//cnt=1
	for(x+=m-1,y+=m+1; x^y^1; x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1,cnt&amp;lt;&amp;lt;=1){
		d[x]+=v*lc;d[y]+=v*rc;
		if(~x&amp;amp;1) laz[x^1]+=v,d[x^1]+=v*cnt,lc+=cnt;
		if(y&amp;amp;1)  laz[y^1]+=v,d[y^1]+=v*cnt,rc+=cnt;		

	}
for(;x;x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1)d[x]+=v*lc,d[y]+=v*rc;
}
int main(){
long long q;
cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;q;
build();
while(q--){
	long long a,b,op,c;
	cin&amp;gt;&amp;gt;op&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
	if(op==1){
		cin&amp;gt;&amp;gt;c;
		add(a,b,c);
	}else{
		
		cout&amp;lt;&amp;lt;get(a,b)&amp;lt;&amp;lt;endl;
		
	}
	
	
}




} 
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>排序时间复杂度</title>
      <link>https://cywd123.github.io/old/posts/3ilwt_ogfy/</link>
      <pubDate>Mon, 10 Mar 2025 13:21:35 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/3ilwt_ogfy/</guid>
      <description>&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;排序方法&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;时间复杂度（平均）&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;时间复杂度（最坏)&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;时间复杂度（最好)&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;稳定性&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;复杂性&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;直接插入排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;简单&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;希尔排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;较复杂&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;直接选择排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;简单&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;堆排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;较复杂&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;冒泡排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;简单&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;快速排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;较复杂&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;归并排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;较复杂&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;基数排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(d(n+r))&lt;/td&gt;
          &lt;td&gt;O(d(n+r))&lt;/td&gt;
          &lt;td&gt;O(d(n+r))&lt;/td&gt;
          &lt;td&gt;O(n+r)&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;较复杂&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    <item>
      <title>【深度学习】手写数字图像识别分类（MNIST数据集）</title>
      <link>https://cywd123.github.io/old/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%88%86%E7%B1%BBmnist%E6%95%B0%E6%8D%AE%E9%9B%86/</link>
      <pubDate>Sat, 01 Apr 2023 20:09:50 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%88%86%E7%B1%BBmnist%E6%95%B0%E6%8D%AE%E9%9B%86/</guid>
      <description>&lt;h1 id=&#34;卷积神经网络&#34;&gt;卷积神经网络&lt;/h1&gt;
&lt;h2 id=&#34;mnist介绍&#34;&gt;MNIST介绍&lt;/h2&gt;
&lt;p&gt;MNIST 数据集可在 &lt;a href=&#34;http://yann.lecun.com/exdb/mnist/&#34;&gt;http://yann.lecun.com/exdb/mnist/&lt;/a&gt; 获取, 它包含了四个部分:&lt;/p&gt;
&lt;p&gt;Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)&lt;br&gt;
Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)&lt;br&gt;
Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)&lt;br&gt;
Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签)&lt;/p&gt;
&lt;p&gt;MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST). 训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据.&lt;/p&gt;</description>
    </item>
    <item>
      <title>【机器学习】四层人工神经网络拟合二元二次函数</title>
      <link>https://cywd123.github.io/old/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%B1%82%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%8B%9F%E5%90%88%E4%BA%8C%E5%85%83%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 29 Mar 2023 17:54:00 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%B1%82%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%8B%9F%E5%90%88%E4%BA%8C%E5%85%83%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h1 id=&#34;四层人工神经网络拟合二元二次函数&#34;&gt;四层人工神经网络拟合二元二次函数&lt;/h1&gt;
&lt;p&gt;如果想了解人工神经网络，请认真阅读每个字，字字珠玑。😂&lt;/p&gt;
&lt;p&gt;核心代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、、、、、、、、、、&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Net&lt;/span&gt;(nn&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Module):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        super(Net, self)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fc1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nn&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Linear(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fc2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nn&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Linear(&lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fc3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;nn&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Linear(&lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fc4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;nn&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Linear(&lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;forward&lt;/span&gt;(self,x):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fc4(t&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;relu(self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fc3(t&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;relu(self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fc2(t&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;relu(self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fc1(x)))))))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;train&lt;/span&gt;(epoch,model,opt,lossfn,tu,tc):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,epoch&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        tp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;model(tu)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        loss&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;lossfn(tp,tc)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        opt&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;zero_grad()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        loss&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;backward()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        opt&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;step()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Epoch &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;, Loss &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (i, float(loss)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; model
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;(x,x2):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;x2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;PATH &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cyNN.pt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cyNN&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;t&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load(PATH)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cyNN&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;eval()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;opt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;optim&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Adam(cyNN&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;parameters(),lr&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1e-7&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、、、、、、、、、、&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们这个模型拟合的函数是：f(x,x2)=x^2+x2&lt;/p&gt;
&lt;h4 id=&#34;最最重要的核心调用框架&#34;&gt;最最重要的核心调用框架&lt;/h4&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cywd123.github.io/images/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%9B%9B%E5%B1%82%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%8B%9F%E5%90%88%E4%BA%8C%E5%85%83%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0/1741976905763.jpg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;神经网络解释&#34;&gt;神经网络解释&lt;/h2&gt;
&lt;p&gt;这是一个四层人工神经网络，拟合二元二次函数。&lt;/p&gt;
&lt;p&gt;输入层有两个神经元，输出层有一个神经元，中间两层各有40个神经元，最后一层有24个神经元。激活函数使用的是ReLU，优化器使用的是Adam，学习率为1e-7，损失函数使用的是MSELoss。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入层：2个神经元  （表示两个自变量）
隐藏层1：40个神经元
隐藏层2：40个神经元
隐藏层3：24个神经元
输出层：1个神经元   （表示一个因变量）
激活函数：ReLU （线性整流函数）
优化器：Adam 
学习率：1e-7 
损失函数：MSELoss(即均方误差，也就是绝对误差的平方)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;结构图&#34;&gt;结构图&lt;/h4&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cywd123.github.io/images/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%9B%9B%E5%B1%82%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%8B%9F%E5%90%88%E4%BA%8C%E5%85%83%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0/1741976913419.jpg&#34;&gt;&lt;br&gt;
(一目了然这个属于是=。=）&lt;/p&gt;</description>
    </item>
    <item>
      <title>【机器学习】可拟合任意线性函数的小玩意儿</title>
      <link>https://cywd123.github.io/old/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%AF%E6%8B%9F%E5%90%88%E4%BB%BB%E6%84%8F%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%8F%E7%8E%A9%E6%84%8F%E5%84%BF/</link>
      <pubDate>Mon, 27 Mar 2023 22:27:23 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%AF%E6%8B%9F%E5%90%88%E4%BB%BB%E6%84%8F%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%8F%E7%8E%A9%E6%84%8F%E5%84%BF/</guid>
      <description>&lt;h1 id=&#34;机器学习可拟合任意线性函数的小玩意儿&#34;&gt;【机器学习】可拟合任意线性函数的小玩意儿&lt;/h1&gt;
&lt;h3 id=&#34;先上完整代码&#34;&gt;先上完整代码&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import torch as t
import torch.nn as nn
import torch.optim as optim

def training_loop(n_epochs, optimizer, model,loss_fn, t_u, t_c):
    for epoch in range(1, n_epochs + 1):
        t_p = model(t_u)          #计算当前模型的预测值
        loss = loss_fn(t_p, t_c)  #计算损失函数
        optimizer.zero_grad()   
        loss.backward()   #回溯累计损失
        optimizer.step()
        if epoch % 50 == 0:
            print(&amp;#39;Epoch %d, Loss %f&amp;#39; % (epoch, float(loss)))
    return model


epoches=30000  #迭代次数 一般次数适中，为防止过度拟合不建议迭代次数过多
num=50000  #随机生成的样本数 一般越多越好，看运行配置

learning_rate=1e-4   #学习率（数值越大学得越快（但不一定准确），数值越小拟合越好（时间较长））建议取 1e-2 、1e-3、1e-4、1e-5

x = t.randn(num, 1)
def f(x):
    return 30 * x + 10
    #待拟合的式子为 y=30*x +10  可自行修改if you like。


y = f(x)+ t.randn(num, 1)*10  #  后面的 t.randn(num, 1)*10 是偏离值，降低训练的精确性（给你的模型更多的挑战）
linear_model = nn.Linear(1, 1)
optimizer = optim.SGD(linear_model.parameters(), lr=learning_rate)
training_loop(n_epochs=epoches,optimizer=optimizer,model=linear_model,loss_fn=nn.MSELoss(),t_u=x,t_c=y)
print(&amp;#39;\n&amp;#39;)
#print(linear_model.weight)
#print(linear_model.bias)

while(1):
    x=float(input(&amp;#39;请输入想预测的x值：&amp;#39;))
    tmp=float(linear_model(t.tensor([x]))[0])
    print(&amp;#34;拟合值:&amp;#34;,tmp)
    print(&amp;#34;真实值:&amp;#34;,f(x))
    print(&amp;#34;相对误差:&amp;#34;,1-tmp/f(x))
    print(&amp;#39;\n&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个程序可以分为两个部分(生成训练数据、机器学习模型)，其中生成训练数据部分可有可无(因为在实际应用中，一般数据为人工导入，不是系统随机生成)。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【爬虫】豆瓣Top250爬取</title>
      <link>https://cywd123.github.io/old/posts/%E7%88%AC%E8%99%AB%E8%B1%86%E7%93%A3top250%E7%88%AC%E5%8F%96/</link>
      <pubDate>Sun, 26 Mar 2023 23:44:33 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/%E7%88%AC%E8%99%AB%E8%B1%86%E7%93%A3top250%E7%88%AC%E5%8F%96/</guid>
      <description>&lt;h1 id=&#34;豆瓣top250爬取&#34;&gt;豆瓣Top250爬取&lt;/h1&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cywd123.github.io/images/%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91%E8%B1%86%E7%93%A3Top250%E7%88%AC%E5%8F%96/1741976760243.jpg&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;这里是简单的代码&#34;&gt;这里是简单的代码&lt;/h5&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cywd123.github.io/images/%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91%E8%B1%86%E7%93%A3Top250%E7%88%AC%E5%8F%96/1741976763554.jpg&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;这里是不断修改ua的过程每次请求都会随机生成一个ua这样就可以绕过豆瓣的反爬虫机制了&#34;&gt;这里是不断修改UA的过程，每次请求都会随机生成一个UA，这样就可以绕过豆瓣的反爬虫机制了&lt;/h5&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cywd123.github.io/images/%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91%E8%B1%86%E7%93%A3Top250%E7%88%AC%E5%8F%96/1741976779793.jpg&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;这里是爬虫的结果&#34;&gt;这里是爬虫的结果&lt;/h5&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cywd123.github.io/images/%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91%E8%B1%86%E7%93%A3Top250%E7%88%AC%E5%8F%96/1741976793865.jpg&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;结果被豆瓣网站检测到了不过我们的爬虫已经圆满的完成了任务我们可以看到豆瓣网站的反爬虫机制是通过检测请求头中的user-agent来判断是否是爬虫所以我们可以通过修改请求头中的user-agent来绕过反爬虫机制&#34;&gt;结果被豆瓣网站检测到了，不过我们的爬虫已经圆满的完成了任务，我们可以看到豆瓣网站的反爬虫机制是通过检测请求头中的User-Agent来判断是否是爬虫，所以我们可以通过修改请求头中的User-Agent来绕过反爬虫机制。&lt;/h5&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cywd123.github.io/images/%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91%E8%B1%86%E7%93%A3Top250%E7%88%AC%E5%8F%96/1741976799043.jpg&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>【爬虫】FitGirl-Repack的Scrapy爬虫代码</title>
      <link>https://cywd123.github.io/old/posts/fitgirl-repack%E6%B8%B8%E6%88%8F%E7%BD%91%E7%AB%99scrapy%E7%88%AC%E8%99%AB%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Wed, 15 Mar 2023 15:53:25 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/fitgirl-repack%E6%B8%B8%E6%88%8F%E7%BD%91%E7%AB%99scrapy%E7%88%AC%E8%99%AB%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;h2 id=&#34;今天花了一点时间写了一个fitgirl-repacks游戏网站的自动爬虫脚本&#34;&gt;今天花了一点时间，写了一个&lt;a href=&#34;https://fitgirl-repacks.site/&#34; title=&#34;FitGirl Repacks&#34;&gt;FitGirl Repacks&lt;/a&gt;游戏网站的自动爬虫脚本&lt;/h2&gt;
&lt;p&gt;用的是scrapy的爬虫框架&lt;/p&gt;
&lt;h4 id=&#34;itemspy-作用确定需要爬取的内容&#34;&gt;items.py 作用：确定需要爬取的内容&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import scrapy

class Fg1Item(scrapy.Item):
	# define the fields for your item here like:
	# name = scrapy.Field()
	tle = scrapy.Field()
	info = scrapy.Field()
	pass
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里，我选择爬取两样信息：title 和 info ，分别对应各个游戏的标题名称 和 下载地址&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;fgpy-作用爬虫的逻辑结构&#34;&gt;FG.py 作用：爬虫的逻辑结构&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import scrapy
from FG1.items import Fg1Item

class FgSpider(scrapy.Spider):
	name = &amp;#34;FG&amp;#34;
	allowed_domains = [&amp;#34;fitgirl-repacks.site&amp;#34;]
	start_urls = [&amp;#34;http://fitgirl-repacks.site/&amp;#34;]

	def parse(self, response):
    	for i in range(1,350):
       		yield scrapy.Request(&amp;#34;https://fitgirl-repacks.site/page/&amp;#34;+str(i)+&amp;#39;/&amp;#39;,callback=self.parse_page)
    	pass
	def parse_page(self, response):
    	for each in response.xpath(&amp;#34;//article&amp;#34;):
        	item=Fg1Item()
        	item[&amp;#39;tle&amp;#39;]=each.xpath(&amp;#34;header/h1/a/text()&amp;#34;).extract()
        	item[&amp;#39;info&amp;#39;]=each.xpath(&amp;#34;div/ul[1]&amp;#34;).extract()
        	yield item
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;逻辑结构分为两层：&lt;/p&gt;</description>
    </item>
    <item>
      <title>TinyWebDB的简单思考</title>
      <link>https://cywd123.github.io/old/posts/tinywebdb%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%9D%E8%80%83/</link>
      <pubDate>Wed, 21 Dec 2022 22:10:55 +0000</pubDate>
      <guid>https://cywd123.github.io/old/posts/tinywebdb%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%9D%E8%80%83/</guid>
      <description>&lt;p&gt;部分核心代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
	$tag = urldecode($_POST[&amp;#39;tag&amp;#39;]);            //获得POST参数，URL解码

	if (strpos($_SERVER[&amp;#34;REQUEST_URI&amp;#34;], &amp;#39;storeavalue&amp;#39;)) //判断HTTP请求头
	{
    //储存数据
    $sql = &amp;#34;SELECT * FROM tinywebdb WHERE tag=&amp;#39;&amp;#34;.$tag.&amp;#34;&amp;#39;&amp;#34;;        //SQL
    $result = $conn-&amp;gt;query($sql);
    if ($result-&amp;gt;num_rows &amp;gt; 0) {
        $sql = &amp;#34;UPDATE tinywebdb SET value = &amp;#39;&amp;#34;.$_POST[&amp;#39;value&amp;#39;].&amp;#34;&amp;#39; where tag=&amp;#39;&amp;#34;.$tag.&amp;#34;&amp;#39;&amp;#34;;
    } else {
        $sql = &amp;#34;INSERT INTO tinywebdb &amp;#34;.&amp;#34;(tag,value) &amp;#34;.&amp;#34;VALUES (&amp;#39;&amp;#34;.$tag.&amp;#34;&amp;#39;,&amp;#39;&amp;#34;.$_POST[&amp;#39;value&amp;#39;].&amp;#34;&amp;#39;)&amp;#34;;
    }
    $retval = mysqli_query($conn, $sql);        //传递SQL命令
	} elseif(strpos($_SERVER[&amp;#34;REQUEST_URI&amp;#34;], &amp;#39;getvalue&amp;#39;))
	{
    //查询数据
    $sql = &amp;#34;SELECT * FROM tinywebdb WHERE tag=&amp;#39;&amp;#34;.$tag.&amp;#34;&amp;#39;&amp;#34;;        //SQL
    $result = $conn-&amp;gt;query($sql);
    if ($result-&amp;gt;num_rows &amp;gt; 0) {
        while ($row = $result-&amp;gt;fetch_assoc()) {
            $results = array(&amp;#34;VALUE&amp;#34;, $tag, urldecode($row[&amp;#34;value&amp;#34;]));            //
            $result_in_JSON = json_encode($results);                             //  JSON编码
            echo $result_in_JSON;                                               //
        }
    } else {
            $results = array(&amp;#34;VALUE&amp;#34;, $tag, &amp;#34;&amp;#34;);        
            $result_in_JSON = json_encode($results);             
            echo $result_in_JSON;
    }
	}else{
    ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实主要还是查看了文献，用PHP模拟官方使用API接口格式。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
