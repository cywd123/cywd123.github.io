<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Juiceright</title>
    <link>https://cywd123.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Juiceright</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Dec 2025 10:14:17 +0000</lastBuildDate>
    <atom:link href="https://cywd123.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>zkw线段树</title>
      <link>https://cywd123.github.io/posts/uljgqekoo3/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:55 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/uljgqekoo3/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&#xA;#include&amp;lt;bits/stdc++.h&amp;gt;&#xA;using namespace std;&#xA;int d[500000*4],n,m=1;&#xA;&#xA;&#xA;inline void build(int n){&#xA;&#x9;while(m&amp;lt;=n)m&amp;lt;&amp;lt;=1;&#xA;    for(int i=m+1;i&amp;lt;=m+n;i++) cin&amp;gt;&amp;gt;d[i];&#xA;    for(int i=m-1;i;--i) d[i]=d[i&amp;lt;&amp;lt;1]+d[i&amp;lt;&amp;lt;1|1]; &#xA;}  &#xA;&#xA;void chg(int x,int v){&#xA;    d[x=m+x]+=v;&#xA;    while(x) d[x&amp;gt;&amp;gt;=1]=d[x&amp;lt;&amp;lt;1]+d[x&amp;lt;&amp;lt;1|1];&#xA;}  &#xA;&#xA;int add(int x,int v){&#xA;&#x9;for(int i=x+m;i;i&amp;gt;&amp;gt;=1)d[i]+=v;&#xA;}&#xA;int ask(int l,int r){&#xA;int ans=0;&#xA;for(l=m+l-1,r=m+r+1 ; l^r^1 ; l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1){&#xA;&#x9;if(~l&amp;amp;1)ans+=d[l^1];&#xA;if(r&amp;amp;1)ans+=d[r^1];&#xA;}&#xA;return ans;&#xA;}&#xA;void debug(){&#xA;&#x9;for(int i=m+1;i&amp;lt;=m+n;i++)cout&amp;lt;&amp;lt;d[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;;&#xA;&#x9;cout&amp;lt;&amp;lt;m&amp;lt;&amp;lt;endl;&#xA;&#x9;&#xA;}&#xA;int main(){&#xA;int q;&#xA;cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;q;&#xA;build(n);&#xA;while(q--){&#xA;&#x9;int op,a,b;&#xA;&#x9;cin&amp;gt;&amp;gt;op&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;&#xA;&#x9;if(op==1)add(a,b);&#xA;&#x9;else cout&amp;lt;&amp;lt;ask(a,b)&amp;lt;&amp;lt;endl;&#xA;}&#xA;&#xA;&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>ST表</title>
      <link>https://cywd123.github.io/posts/6jfataceqh/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:40 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/6jfataceqh/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&#xD;&#xA;#include&amp;lt;bits/stdc++.h&amp;gt;&#xD;&#xA;using namespace std;&#xD;&#xA;int f[2000010][24],n;&#xD;&#xA;int get(int x,int y){&#xD;&#xA;&#x9;int k=log(y-x+1)/log(2);&#xD;&#xA;&#x9;return max(f[x][k],f[y-(1&amp;lt;&amp;lt;k)+1][k]);&#xD;&#xA;}&#xD;&#xA;int main(){&#xD;&#xA;&#x9;int i,j,m,t,k;&#xD;&#xA;&#x9;scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;n,&amp;amp;m);&#xD;&#xA;&#x9;for(i=1;i&amp;lt;=n;i++)&#xD;&#xA;&#x9;scanf(&amp;#34;%d&amp;#34;,&amp;amp;f[i][0]);&#xD;&#xA;&#x9;int x=log(n)/log(2)+1;&#xD;&#xA;&#x9;for(int j=1;j&amp;lt;x;j++)&#xD;&#xA;&#x9;for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)&#xD;&#xA;&#x9;f[i][j]=max(f[i][j-1],f[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);&#xD;&#xA;&#x9;while(m--){&#xD;&#xA;&#x9;&#x9;int a,b;&#xD;&#xA;&#x9;&#x9;scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a,&amp;amp;b);&#xD;&#xA;&#x9;&#x9;printf(&amp;#34;%d\n&amp;#34;,get(a,b));&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>SPFA算法</title>
      <link>https://cywd123.github.io/posts/ldovg2gc2p/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:27 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/ldovg2gc2p/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;&#xD;&#xA;using namespace std;&#xD;&#xA;const long long   N=100010,M=200011;&#xD;&#xA;long long   head[N],ver[M],edge[M],Next[M],d[N];&#xD;&#xA;long long   n,m,tot=0;&#xD;&#xA;queue&amp;lt;long long &amp;gt;q;&#xD;&#xA;bool v[N];&#xD;&#xA;void add(long long   x,long long   y,long long   z){&#xD;&#xA;&#x9;ver[++tot]=y;edge[tot]=z;Next[tot]=head[x];&#xD;&#xA;&#x9;head[x]=tot;&#xD;&#xA;}&#xD;&#xA;int main(){&#xD;&#xA;long long   i,j,n,m,a,b,c,s;&#xD;&#xA;scanf(&amp;#34;%lld %lld %lld&amp;#34;,&amp;amp;n,&amp;amp;m,&amp;amp;s);&#xD;&#xA;while(m--){&#xD;&#xA;scanf(&amp;#34;%lld %lld %lld&amp;#34;,&amp;amp;a,&amp;amp;b,&amp;amp;c);&#xD;&#xA;add(a,b,c);&#xD;&#xA;//&#x9;add(b,a,c);&#xD;&#xA;}&#xD;&#xA;memset(d,0x3f,sizeof(d));&#xD;&#xA;memset(v,0,sizeof(v));&#xD;&#xA;d[s]=0;&#xD;&#xA;v[s]=1;&#xD;&#xA;q.push(1);&#xD;&#xA;while(q.size())&#xD;&#xA;{&#xD;&#xA;&#x9;long long   x=q.front();&#xD;&#xA;&#x9;q.pop();&#xD;&#xA;&#x9;v[x]=0;&#xD;&#xA;&#x9;for(long long  i=head[x];i;i=Next[i])&#xD;&#xA;&#x9;{long long   y=ver[i],z=edge[i];&#xD;&#xA;&#x9;if(d[y]&amp;gt;d[x]+z){&#xD;&#xA;&#x9;&#x9;d[y]=d[x]+z;&#xD;&#xA;&#x9;&#x9;if(!v[y])&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;q.push(y);&#xD;&#xA;&#x9;&#x9;&#x9;v[y]=1;&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;for(i=1;i&amp;lt;=n;i++)&#xD;&#xA;cout&amp;lt;&amp;lt;d[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Prim算法</title>
      <link>https://cywd123.github.io/posts/f481dm04tj/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:15 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/f481dm04tj/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&#xA;#include&amp;lt;bits/stdc++.h&amp;gt;&#xA;using namespace std;&#xA;typedef int ll;&#xA;&#xA;ll d[5010],mp[5010][5010];&#xA;bool v[5010];&#xA;ll i,j,n,m,t,k;&#xA;&#xA;int main() {&#xA;&#x9;cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;&#xA;&#x9;memset(mp,0x3f,sizeof(mp));&#xA;&#x9;memset(d,0x3f,sizeof(d));&#xA;&#x9;memset(v,0,sizeof(v));&#xA;&#x9;ll a,b,c;&#xA;&#xA;&#x9;for(i=1; i&amp;lt;=m; i++) {&#xA;&#x9;&#x9;cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;&#xA;&#xA;&#x9;&#x9;mp[a][b]=min(mp[a][b],c);&#xA;&#xA;&#x9;&#x9;mp[b][a]=mp[a][b];&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;d[1]=0;&#xA;&#xA;&#x9;for(i=1; i&amp;lt;n; i++) {&#xA;&#x9;&#x9;ll x=0;&#xA;&#x9;&#x9;for(j=1; j&amp;lt;=n; j++)&#xA;&#xA;&#x9;&#x9;&#x9;if(!v[j]&amp;amp;&amp;amp;(x==0||d[j]&amp;lt;d[x]))x=j;&#xA;&#xA;&#x9;&#x9;v[x]=1;&#xA;&#x9;&#x9;for(j=1; j&amp;lt;=n; j++)&#xA;&#xA;&#x9;&#x9;&#x9;if(!v[j])d[j]=min(d[j],mp[x][j]);&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;ll ans=0;&#xA;&#x9;for(i=2; i&amp;lt;=n; i++)&#xA;&#x9;&#x9;ans+=d[i];&#xA;&#x9;&#xA;&#x9;if(ans&amp;gt;99999999)cout&amp;lt;&amp;lt;&amp;#34;orz&amp;#34;;&#xA;&#x9;else cout&amp;lt;&amp;lt;ans;&#xA;&#x9;&#xA;&#x9;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Prim堆优化版</title>
      <link>https://cywd123.github.io/posts/ibw-bmba9u/</link>
      <pubDate>Mon, 10 Mar 2025 13:27:52 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/ibw-bmba9u/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;&#xD;&#xA;using namespace std;&#xD;&#xA;priority_queue&amp;lt;pair&amp;lt;long long,long long&amp;gt; &amp;gt;q;&#xD;&#xA;vector&amp;lt;long long&amp;gt;ver[5010],edge[5010];&#xD;&#xA;bool v[5010];&#xD;&#xA;long long d[5010];&#xD;&#xA;long long n,m;&#xD;&#xA;void add(long long x,long long y,long long z){&#xD;&#xA;&#x9;ver[x].push_back(y);edge[x].push_back(z);&#xD;&#xA;}&#xD;&#xA;void init(){&#xD;&#xA;&#x9;cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;&#xD;&#xA;&#x9;for(long long i=1;i&amp;lt;=m;i++){&#xD;&#xA;&#x9;&#x9;long long a,b,c;&#xD;&#xA;&#x9;&#x9;cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;&#xD;&#xA;&#x9;&#x9;add(a,b,c);add(b,a,c);&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void work(){&#xD;&#xA;&#x9;memset(d,0x3f,sizeof(d));&#xD;&#xA;&#x9;memset(v,0,sizeof(v));&#xD;&#xA;&#x9;long long ans=0;&#xD;&#xA;&#x9;d[1]=0;&#xD;&#xA;&#x9;q.push(make_pair(0,1));&#xD;&#xA;&#x9;int cnt=0;&#xD;&#xA;&#x9;while(q.size()){&#xD;&#xA;&#x9;&#x9;long long x=q.top().second;&#xD;&#xA;&#x9;&#x9;q.pop();&#xD;&#xA;&#x9;&#x9;if(v[x])continue;&#xD;&#xA;&#x9;&#x9;v[x]=1;&#xD;&#xA;&#x9;&#x9;cnt++;&#xD;&#xA;&#x9;&#x9;for(int i=ver[x].size()-1;i&amp;gt;=0;i--){&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;int y=ver[x][i],z=edge[x][i];&#xD;&#xA;&#x9;&#x9;&#x9;if(!v[y] &amp;amp;&amp;amp;(z&amp;lt;d[y])){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;d[y]=z;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;q.push(make_pair(-d[y],y));&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;}&#xD;&#xA;for(int i=2;i&amp;lt;=n;i++)ans+=d[i];&#xD;&#xA;if(cnt==n)cout&amp;lt;&amp;lt;ans;&#xD;&#xA;else cout&amp;lt;&amp;lt;&amp;#34;orz&amp;#34;;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;int main(){&#xD;&#xA;init();&#xD;&#xA;work();&#xD;&#xA;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>LCA算法</title>
      <link>https://cywd123.github.io/posts/5ipfk_eghq/</link>
      <pubDate>Mon, 10 Mar 2025 13:27:39 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/5ipfk_eghq/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// luogu-judger-enable-o2&#xD;&#xA;#include&amp;lt;bits/stdc++.h&amp;gt;&#xD;&#xA;using namespace std;&#xD;&#xA;int ver[2*500000],nex[2*500000],head[2*500000],d[2*500000],p[2*500000][23],tot;&#xD;&#xA;void add(int x,int y){&#xD;&#xA;&#x9;ver[++tot]=y;nex[tot]=head[x];head[x]=tot;&#xD;&#xA;}&#xD;&#xA;int read(){&#xD;&#xA;&#x9;int x=0;&#xD;&#xA;&#x9;char ch;&#xD;&#xA;&#x9;while(ch&amp;lt;&amp;#39;0&amp;#39;||ch&amp;gt;&amp;#39;9&amp;#39;)ch=getchar();&#xD;&#xA;&#x9;while(ch&amp;gt;&amp;#39;0&amp;#39;&amp;amp;&amp;amp;ch&amp;lt;&amp;#39;9&amp;#39;){&#xD;&#xA;&#x9;&#x9;x=x*10+ch-&amp;#39;0&amp;#39;;&#xD;&#xA;&#x9;&#x9;ch=getchar();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return x;&#xD;&#xA;}&#xD;&#xA;void dfs(int x,int fa){&#xD;&#xA;&#x9;d[x]=d[fa]+1;&#xD;&#xA;&#x9;p[x][0]=fa;&#xD;&#xA;&#x9;for(int i=1;(1&amp;lt;&amp;lt;i)&amp;lt;=d[x];i++)&#xD;&#xA;&#x9;p[x][i]=p[p[x][i-1]][i-1];&#xD;&#xA;&#x9;for(int i=head[x];i;i=nex[i]){&#xD;&#xA;&#x9;&#x9;if(ver[i]!=fa)&#xD;&#xA;&#x9;&#x9;dfs(ver[i],x);&#x9;&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;int lca(int a,int b){&#xD;&#xA;&#x9;if(d[a]&amp;gt;d[b])swap(a,b);&#xD;&#xA;&#x9;for(int i=20;i&amp;gt;=0;i--)&#xD;&#xA;&#x9;if(d[a]&amp;lt;=d[b]-(1&amp;lt;&amp;lt;i))&#xD;&#xA;&#x9;b=p[b][i];&#xD;&#xA;&#x9;if(a==b)&#xD;&#xA;&#x9;return a;&#xD;&#xA;&#x9;for(int i=20;i&amp;gt;=0;i--)&#xD;&#xA;&#x9;if(p[a][i]==p[b][i])continue;&#xD;&#xA;&#x9;else a=p[a][i],b=p[b][i];&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;return p[a][0];&#xD;&#xA;}&#xD;&#xA;int main(){&#xD;&#xA;&#x9;int i,j,n,m,t,k,s;&#xD;&#xA;&#x9;scanf(&amp;#34;%d %d %d&amp;#34;,&amp;amp;n,&amp;amp;m,&amp;amp;s);&#xD;&#xA;&#x9;for(int i=1;i&amp;lt;n;i++)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;int a,b;&#xD;&#xA;&#x9;&#x9;scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a,&amp;amp;b);&#xD;&#xA;&#x9;&#x9;add(a,b);&#xD;&#xA;&#x9;&#x9;add(b,a);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;dfs(s,0);&#xD;&#xA;&#x9;for(i=1;i&amp;lt;=m;i++)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;int a,b;&#xD;&#xA;&#x9;scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a,&amp;amp;b);&#xD;&#xA;&#x9;&#x9;cout&amp;lt;&amp;lt;lca(a,b)&amp;lt;&amp;lt;endl;&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>匈牙利算法</title>
      <link>https://cywd123.github.io/posts/rnbllzkklq/</link>
      <pubDate>Mon, 10 Mar 2025 13:27:28 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/rnbllzkklq/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;&#xA;using namespace std;&#xA;bool ver[1001][1001],v[1001];&#xA;int d[1001],n,m,e;&#xA;bool dfs(int x){&#xA;&#x9;for(int i=1;i&amp;lt;=m;i++){&#xA;&#x9;if(ver[x][i]&amp;amp;&amp;amp;!v[i]){&#xA;&#x9;&#x9;v[i]=1;&#xA;&#x9;&#x9;if(!d[i]||dfs(d[i])){&#xA;&#x9;&#x9;&#x9;d[i]=x;return 1;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#x9;return 0;&#xA;}&#xA;void init(){&#xA;cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;e;&#xA;for(int i=1;i&amp;lt;=e;i++){&#xA;&#x9;int a,b;&#xA;&#x9;cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;&#xA;&#x9;if(b&amp;gt;m||a&amp;gt;n)continue;&#xA;&#x9;ver[a][b]=1;&#xA;&#xA;}&#xA;&#x9;int ans=0;&#xA;&#x9;for(int i=1;i&amp;lt;=n;i++){memset(v,0,sizeof(v));&#xA;&#x9;ans+=dfs(i);&#xA;&#x9;}&#xA;&#x9;cout&amp;lt;&amp;lt;ans;&#xA;}&#xA;int main(){&#xA;init();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>线段树</title>
      <link>https://cywd123.github.io/posts/cse8xfl8mp/</link>
      <pubDate>Mon, 10 Mar 2025 13:26:55 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/cse8xfl8mp/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;&#xD;&#xA;using namespace std;&#xD;&#xA;struct pl{&#xD;&#xA;&#x9;long long l,r,v,add,tim;&#xD;&#xA;&#x9;#define l(x) tree[x].l&#xD;&#xA;&#x9;#define r(x) tree[x].r&#xD;&#xA;&#x9;#define v(x) tree[x].v&#xD;&#xA;&#x9;#define add(x) tree[x].add&#xD;&#xA;}tree[4*100000];&#xD;&#xA;long long a[100001];&#xD;&#xA;void build(long long p,long long l,long long r){&#xD;&#xA;&#x9;l(p)=l;r(p)=r;&#xD;&#xA;&#x9;if(l==r){&#xD;&#xA;&#x9;&#x9;v(p)=a[l];return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;long long mid=(l+r)&amp;gt;&amp;gt;1;&#xD;&#xA;&#x9;build(p&amp;lt;&amp;lt;1,l,mid);&#xD;&#xA;&#x9;build((p&amp;lt;&amp;lt;1)+1,mid+1,r);&#xD;&#xA;&#x9;v(p)=v(p*2)+v(p*2+1);&#xD;&#xA;}&#xD;&#xA;void spread(long long p){&#xD;&#xA;&#x9;if(add(p)==0)return;&#xD;&#xA;&#x9;v(p*2)+=add(p)*(r(p*2)-l(p*2)+1);&#xD;&#xA;&#x9;v(p*2+1)+=add(p)*(r(p*2+1)-l(p*2+1)+1);&#xD;&#xA;&#x9;add(p*2)+=add(p);&#xD;&#xA;&#x9;add(p*2+1)+=add(p);&#xD;&#xA;&#x9;add(p)=0;&#xD;&#xA;}&#xD;&#xA;void chg(long long p,long long l,long long r,long long d){&#xD;&#xA;&#x9;if(l&amp;lt;=l(p)&amp;amp;&amp;amp;r&amp;gt;=r(p)){&#xD;&#xA;&#x9;&#x9;v(p)+=d*(r(p)-l(p)+1);&#xD;&#xA;&#x9;&#x9;add(p)+=d;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;spread(p);&#xD;&#xA;&#x9;long long mid=(l(p)+r(p))&amp;gt;&amp;gt;1;&#xD;&#xA;&#x9;if(l&amp;lt;=mid)chg(p*2,l,r,d);&#xD;&#xA;&#x9;if(r&amp;gt;mid)chg(p*2+1,l,r,d);&#xD;&#xA;&#x9;v(p)=v(p*2)+v(p*2+1);&#xD;&#xA;}&#xD;&#xA;long long ask(long long p,long long l,long long r){&#xD;&#xA;&#x9;if(l&amp;lt;=l(p)&amp;amp;&amp;amp;r&amp;gt;=r(p))return v(p);&#xD;&#xA;&#x9;spread(p);&#xD;&#xA;&#x9;long long mid=(l(p)+r(p))&amp;gt;&amp;gt;1;&#xD;&#xA;&#x9;long long ans=0;&#xD;&#xA;&#x9;if(l&amp;lt;=mid)ans+=ask(p*2,l,r);&#xD;&#xA;&#x9;if(r&amp;gt;mid)ans+=ask(p*2+1,l,r);&#xD;&#xA;&#x9;return ans;&#xD;&#xA;}&#xD;&#xA;int main(){&#xD;&#xA;long long i,j,n,m,t,k;&#xD;&#xA;cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;&#xD;&#xA;for(i=1;i&amp;lt;=n;i++)cin&amp;gt;&amp;gt;a[i];&#xD;&#xA;build(1,1,n);&#xD;&#xA;while(m--){&#xD;&#xA;&#x9;long long op,l,r,k;&#xD;&#xA;&#x9;cin&amp;gt;&amp;gt;op&amp;gt;&amp;gt;l&amp;gt;&amp;gt;r;&#xD;&#xA;&#x9;if(op==1){&#xD;&#xA;&#x9;&#x9;cin&amp;gt;&amp;gt;k;&#xD;&#xA;&#x9;&#x9;chg(1,l,r,k);&#xD;&#xA;&#x9;}else cout&amp;lt;&amp;lt;ask(1,l,r)&amp;lt;&amp;lt;endl;&#x9;&#xD;&#xA;}&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>树状数组</title>
      <link>https://cywd123.github.io/posts/hl1binzfbh/</link>
      <pubDate>Mon, 10 Mar 2025 13:26:42 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/hl1binzfbh/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&#xD;&#xA;#include&amp;lt;bits/stdc++.h&amp;gt;&#xD;&#xA;using namespace std;&#xD;&#xA;long long c[500001];&#xD;&#xA;&#x9;long long i,j,n,m,t,k;&#xD;&#xA;long long lb(long long x)&#xD;&#xA;{return x&amp;amp;(-x);&#xD;&#xA;}&#xD;&#xA;long long get(long long x)&#xD;&#xA;{&#xD;&#xA;&#x9;long long ans=0;&#xD;&#xA;&#x9;for(;x;x-=lb(x))&#xD;&#xA;&#x9;ans+=c[x];&#xD;&#xA;&#x9;return ans;&#xD;&#xA;}&#xD;&#xA;void add(long long x,long long y){&#xD;&#xA;&#x9;for(long long i=x;i&amp;lt;=n;i+=lb(i))&#xD;&#xA;&#x9;c[i]+=y;&#xD;&#xA;&#x9;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;int main(){&#xD;&#xA;&#xD;&#xA;&#x9;cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;&#xD;&#xA;&#x9;for(i=1;i&amp;lt;=n;i++)&#xD;&#xA;&#x9;{scanf(&amp;#34;%lld&amp;#34;,&amp;amp;t);&#xD;&#xA;&#x9;add(i,t);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;while(m--){&#xD;&#xA;&#x9;&#x9;cin&amp;gt;&amp;gt;t;&#xD;&#xA;&#x9;&#x9;if(t==1){&#xD;&#xA;&#x9;&#x9;&#x9;cin&amp;gt;&amp;gt;j&amp;gt;&amp;gt;k;&#xD;&#xA;&#x9;&#x9;&#x9;add(j,k);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;else {&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;cin&amp;gt;&amp;gt;j&amp;gt;&amp;gt;k;&#xD;&#xA;&#x9;&#x9;&#x9;cout&amp;lt;&amp;lt;get(k)-get(j-1)&amp;lt;&amp;lt;endl;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>kruskal算法（克鲁斯卡尔算法）</title>
      <link>https://cywd123.github.io/posts/y1ekvamzmi/</link>
      <pubDate>Mon, 10 Mar 2025 13:26:19 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/y1ekvamzmi/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;&#xD;&#xA;#define ll long long&#xD;&#xA;using namespace std;&#xD;&#xA;ll fa[5010];&#xD;&#xA;ll get(ll x) {&#xD;&#xA;&#x9;return x==fa[x]?x:fa[x]=get(fa[x]);&#xD;&#xA;}&#xD;&#xA;void mrg(ll a,ll b) {&#xD;&#xA;fa[get(a)]=get(b);&#xD;&#xA;}&#xD;&#xA;struct pl{&#xD;&#xA;&#x9;ll x,y,z;&#xD;&#xA;&#x9;bool operator&amp;lt;(const pl &amp;amp;a){&#xD;&#xA;&#x9;return z&amp;lt;a.z;&#xD;&#xA;&#x9;}&#xD;&#xA;}mp[200001];&#xD;&#xA;int main() {&#xD;&#xA;ll i,j,n,m,t=0,k=0;&#xD;&#xA;cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;&#xD;&#xA;for(i=1;i&amp;lt;=m;i++)&#xD;&#xA;{&#xD;&#xA;&#x9;cin&amp;gt;&amp;gt;mp[i].x&amp;gt;&amp;gt;mp[i].y&amp;gt;&amp;gt;mp[i].z;&#xD;&#xA;}&#xD;&#xA;sort(mp+1,mp+1+m);&#xD;&#xA;for(i=1;i&amp;lt;=n;i++)fa[i]=i;&#xD;&#xA;for(i=1;i&amp;lt;=m&amp;amp;&amp;amp;t&amp;lt;n;i++){&#xD;&#xA;&#x9;if(get(mp[i].x)!=get(mp[i].y))mrg(mp[i].x,mp[i].y),t++,k+=mp[i].z;&#x9;&#xD;&#xA;}&#xD;&#xA;if(t==n-1)&#xD;&#xA;cout&amp;lt;&amp;lt;k;&#xD;&#xA;else cout&amp;lt;&amp;lt;&amp;#34;orz&amp;#34;;&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>带lazy标记的zkw线段树</title>
      <link>https://cywd123.github.io/posts/wwlgapb2j1/</link>
      <pubDate>Mon, 10 Mar 2025 13:25:58 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/wwlgapb2j1/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&#xD;&#xA;#include&amp;lt;bits/stdc++.h&amp;gt;&#xD;&#xA;using namespace std;&#xD;&#xA;long long d[500000&amp;lt;&amp;lt;2],laz[500000&amp;lt;&amp;lt;2],n,m=1;;&#xD;&#xA;void build(){&#xD;&#xA;&#x9;while(m&amp;lt;=n)m&amp;lt;&amp;lt;=1;&#xD;&#xA;&#x9;for(long long i=m+1;i&amp;lt;=m+n;i++)cin&amp;gt;&amp;gt;d[i];&#xD;&#xA;&#x9;for(long long i=m-1;i&amp;gt;=1;i--)d[i]=d[i&amp;lt;&amp;lt;1]+d[i&amp;lt;&amp;lt;1|1];&#xD;&#xA;}&#xD;&#xA;long long get(long long x,long long y){&#xD;&#xA;&#x9;long long ans=0,lc=0,rc=0,cnt=1;//cnt=1&#xD;&#xA;&#x9;for(x+=m-1,y+=m+1; x^y^1; x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1,cnt&amp;lt;&amp;lt;=1){&#xD;&#xA;&#x9;&#x9;if(laz[x])ans+=laz[x]*lc;&#xD;&#xA;&#x9;&#x9;if(laz[y])ans+=laz[y]*rc;&#xD;&#xA;&#x9;&#x9;if(~x&amp;amp;1)ans+=d[x^1],lc+=cnt;&#xD;&#xA;&#x9;&#x9;if(y&amp;amp;1)ans+=d[y^1],rc+=cnt;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;&#x9;for(;x;x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1)ans+=laz[x]*lc,ans+=laz[y]*rc;&#xD;&#xA;&#x9;return ans;&#xD;&#xA;}&#xD;&#xA;void add(long long x,long long y,long long v){&#xD;&#xA;&#x9;long long ans=0,lc=0,rc=0,cnt=1;//cnt=1&#xD;&#xA;&#x9;for(x+=m-1,y+=m+1; x^y^1; x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1,cnt&amp;lt;&amp;lt;=1){&#xD;&#xA;&#x9;&#x9;d[x]+=v*lc;d[y]+=v*rc;&#xD;&#xA;&#x9;&#x9;if(~x&amp;amp;1) laz[x^1]+=v,d[x^1]+=v*cnt,lc+=cnt;&#xD;&#xA;&#x9;&#x9;if(y&amp;amp;1)  laz[y^1]+=v,d[y^1]+=v*cnt,rc+=cnt;&#x9;&#x9;&#xD;&#xA;&#xD;&#xA;&#x9;}&#xD;&#xA;for(;x;x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1)d[x]+=v*lc,d[y]+=v*rc;&#xD;&#xA;}&#xD;&#xA;int main(){&#xD;&#xA;long long q;&#xD;&#xA;cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;q;&#xD;&#xA;build();&#xD;&#xA;while(q--){&#xD;&#xA;&#x9;long long a,b,op,c;&#xD;&#xA;&#x9;cin&amp;gt;&amp;gt;op&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;&#xD;&#xA;&#x9;if(op==1){&#xD;&#xA;&#x9;&#x9;cin&amp;gt;&amp;gt;c;&#xD;&#xA;&#x9;&#x9;add(a,b,c);&#xD;&#xA;&#x9;}else{&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;cout&amp;lt;&amp;lt;get(a,b)&amp;lt;&amp;lt;endl;&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>排序时间复杂度</title>
      <link>https://cywd123.github.io/posts/3ilwt_ogfy/</link>
      <pubDate>Mon, 10 Mar 2025 13:21:35 +0000</pubDate>
      <guid>https://cywd123.github.io/posts/3ilwt_ogfy/</guid>
      <description>&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;strong&gt;排序方法&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;时间复杂度（平均）&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;时间复杂度（最坏)&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;时间复杂度（最好)&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;稳定性&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;复杂性&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;直接插入排序&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;O(n2)&lt;/td&gt;&#xA;          &lt;td&gt;O(n2)&lt;/td&gt;&#xA;          &lt;td&gt;O(n)&lt;/td&gt;&#xA;          &lt;td&gt;O(1)&lt;/td&gt;&#xA;          &lt;td&gt;稳定&lt;/td&gt;&#xA;          &lt;td&gt;简单&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;希尔排序&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;O(nlog2n)&lt;/td&gt;&#xA;          &lt;td&gt;O(n2)&lt;/td&gt;&#xA;          &lt;td&gt;O(n)&lt;/td&gt;&#xA;          &lt;td&gt;O(1)&lt;/td&gt;&#xA;          &lt;td&gt;不稳定&lt;/td&gt;&#xA;          &lt;td&gt;较复杂&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;直接选择排序&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;O(n2)&lt;/td&gt;&#xA;          &lt;td&gt;O(n2)&lt;/td&gt;&#xA;          &lt;td&gt;O(n2)&lt;/td&gt;&#xA;          &lt;td&gt;O(1)&lt;/td&gt;&#xA;          &lt;td&gt;不稳定&lt;/td&gt;&#xA;          &lt;td&gt;简单&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;堆排序&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;O(nlog2n)&lt;/td&gt;&#xA;          &lt;td&gt;O(nlog2n)&lt;/td&gt;&#xA;          &lt;td&gt;O(nlog2n)&lt;/td&gt;&#xA;          &lt;td&gt;O(1)&lt;/td&gt;&#xA;          &lt;td&gt;不稳定&lt;/td&gt;&#xA;          &lt;td&gt;较复杂&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;冒泡排序&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;O(n2)&lt;/td&gt;&#xA;          &lt;td&gt;O(n2)&lt;/td&gt;&#xA;          &lt;td&gt;O(n)&lt;/td&gt;&#xA;          &lt;td&gt;O(1)&lt;/td&gt;&#xA;          &lt;td&gt;稳定&lt;/td&gt;&#xA;          &lt;td&gt;简单&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;快速排序&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;O(nlog2n)&lt;/td&gt;&#xA;          &lt;td&gt;O(n2)&lt;/td&gt;&#xA;          &lt;td&gt;O(nlog2n)&lt;/td&gt;&#xA;          &lt;td&gt;O(nlog2n)&lt;/td&gt;&#xA;          &lt;td&gt;不稳定&lt;/td&gt;&#xA;          &lt;td&gt;较复杂&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;归并排序&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;O(nlog2n)&lt;/td&gt;&#xA;          &lt;td&gt;O(nlog2n)&lt;/td&gt;&#xA;          &lt;td&gt;O(nlog2n)&lt;/td&gt;&#xA;          &lt;td&gt;O(n)&lt;/td&gt;&#xA;          &lt;td&gt;稳定&lt;/td&gt;&#xA;          &lt;td&gt;较复杂&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;基数排序&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;O(d(n+r))&lt;/td&gt;&#xA;          &lt;td&gt;O(d(n+r))&lt;/td&gt;&#xA;          &lt;td&gt;O(d(n+r))&lt;/td&gt;&#xA;          &lt;td&gt;O(n+r)&lt;/td&gt;&#xA;          &lt;td&gt;稳定&lt;/td&gt;&#xA;          &lt;td&gt;较复杂&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
  </channel>
</rss>
